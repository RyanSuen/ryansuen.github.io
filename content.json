{"meta":{"title":"Microbot Team","subtitle":"MT-ryansuen","description":"description","author":"Ryan Suen","url":"https://ryansuen.github.io"},"pages":[],"posts":[{"title":"测试环境阿里云lNMN环境搭建","slug":"阿里云lNMN环境搭建","date":"2019-02-21T13:46:19.000Z","updated":"2019-03-17T14:40:47.000Z","comments":true,"path":"2019/02/21/阿里云lNMN环境搭建/","link":"","permalink":"https://ryansuen.github.io/2019/02/21/阿里云lNMN环境搭建/","excerpt":"","text":"阿里云lNMN(linux + nginx + mysql + node.js)环境搭建购买服务器登录服务器 略 登录服务器后安装开发包和库文件 输入命令cat /etc/redhat-release,可查看Linux系统版本 执行命令：chkconfig iptables off，关掉防火墙，避免实验中出现服务器无法访问的情况。在真实的生产环境中，请根据实际需求，配置相应的防火墙规则。 执行如下命令，安装LNMN环境所需的开发包和库文件，例如：openssl等。 1yum -y install ntp make openssl openssl-devel pcre pcre-devel libpng libpng-devel libjpeg-6b libjpeg-devel-6b freetype freetype-devel gd gd-devel zlib zlib-devel gcc gcc-c++ libXpm libXpm-devel ncurses ncurses-devel libmcrypt libmcrypt-devel libxml2 libxml2-devel imake autoconf automake screen sysstat compat-libstdc++-33 curl curl-devel 安装过程需要等待1分钟左右。安装完成后，页面显示“Complete!”。 安装nginx 输入命令yum -y install nginx，通过yum的方式安装nginx。 看到Complete！字样表示安装完成。 使用命令 vi /etc/nginx/conf.d/default.conf，进入nginx配置文件“default.conf”的编辑页面。 在Nginx配置文件的编辑页面中，默认监听使用ipv4和ipv6。 使用键盘方向键将光标移动到“listen [::]:80 default_server;”位置，并输入dd命令，删除此行，也就是删除其中监听为ipv6的配置listen [::]80 default_server。因为，目前阿里云使用的是ipv4，若使用ipv6，运行时会报错。完成后，输入“:wq”，保存退出编辑页面。 输入nginx -t命令检查配置是否正确，出现OK字样配置正确，输入命令service nginx start，启动nginx服务器。若页面显示“Starting nignx [OK]”，证明Nginx服务器已启动。若报错，请检查如上Nginx配置是否正确。 打开浏览器，并在地址栏中，输入云中沙箱提供的ECS实例“公网地址”。若页面显示“Welcome to Nginx on EPEL!”，则证明Nginx服务器已部署且启动成功。 执行命令chkconfig –levels 235 nginx on，设置2、3、5级别开机启动nginx。通过设置如上开机启动级别，在下次启动或者运行ECS服务器的时候，就可以自动运行Nignx服务器。 安装Mysql 首先，在安装MySQL之前，执行命令yum -y install mysql mysql-server mysql-devel ，安装mysql及其组件mysql-server，mysql-devel。 等待几秒钟，页面显示“Complete!”，证明已完成MySQL的安装。 输入命令service mysqld start，启动mysql数据库。等待几秒钟，页面显示“Starting mysqld ［ok］”。证明mysql启动成功。 输入命令mysql，进入MySQL数据库的命令页面，证明已经成功安装并运行MySQL数据库。 ps: 此时mysql是无密码状态，注意设置密码。 在mysql的命令行中，输入exit，页面提示“bye”，退出mysql的命令页面。 最后，执行命令chkconfig --levels 235 mysqld on，设置2、3、5级别开机启动mysql。这样，用户在下次启动ECS服务器时，ECS实例会自动运行mysql数据库，无需用户手动启动。 node.js安装linux下nvm安装 执行如下命令安装：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 更多详情参考链接 通过nvm指令查看远端node.js版本（当然也可以官网查看），我们可以选近几个稳定的版本安装。nvm ls-remote。 如: 12345......v8.9.0 (LTS: Carbon)v8.15.1 (Latest LTS: Carbon)v10.15.3 (Latest LTS: Dubnium)...... 其它nvm常用指令 123nvm ls //查看有那些node.js版本nvm use [node版本] //选择当前命令行使用的node.js版本nvm alias default [node版本] //设置命令行默认的node.js版本 可能会出现nvm not command， 解决方案详见链接 安装node.js 通过nvm安装，如执行指令： nvm install v10.15.3, nvm install v8.15.1, nvm install v8.9.0; 执行nvm ls查看所有的node.js版本及默认的node.js版本。 执行命令node -v 查看node.js是否安装成功。如显示正常的版本这表示node.js安装成功。","categories":[],"tags":[]},{"title":"数据校验与加解密","slug":"数据校验与加解密","date":"2019-01-19T08:54:58.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2019/01/19/数据校验与加解密/","link":"","permalink":"https://ryansuen.github.io/2019/01/19/数据校验与加解密/","excerpt":"","text":"先看看小程序的开放数据校验与解密开放数据校验与解密 公钥，私钥，对称非对称，DES加密算法，AES加密算法，RSA加密算法，Base64加密算法，MD5加密算法等的定义 略 openssl的使用mac 本省自带openssl可通过如下命令查看12➜ .ssh openssl versionLibreSSL 2.2.7 命令行cd到公私密钥需要生成的目录 生成公钥： openssl genrsa -out rsa_private_key.pem 1024 生成私钥: openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 拓展指令 使用终端进入到制定目录下 运行命令：openssl 生成一个1024位的私钥：genrsa -out rsa_private_key.pem 1024 利用私钥生成JAVA支持的PKCS8类型的私钥：pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out pkcs8_private_key.pem 生成JAVA支持的PKCS8二进制类型的私钥：pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform DER -nocrypt -out pkcs8_private_key.der（java端使用的私钥就是这个：pkcs8_private_key.der） 生成公钥：rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 创建证书请求：req -new -out cert.csr -key rsa_private_key.pem（其间会要求填写国家地区公司信息等，随便填写OR认真填写都不影响证书使用） 创建X509的自签署跟证书（iOS支持X509，有效期3650天）：x509 -req -in cert.csr -out rsa_public_key.der -outform der -signkey rsa_private_key.pem -days 3650（iOS端使用的私钥就是这个：rsa_public_key.der） 下面创建iOS端的密钥（p12） x509 -req -days 3650 -in cert.csr -signkey rsa_private_key.pem -out rsacert.crt pkcs12 -export -out p.p12 -inkey rsa_private_key.pem -in rsacert.crt node.js公钥，私钥加解密一例123456789101112131415const fs = require('fs');const crypto = require('crypto');const publicKey = fs.readFileSync('./pem/rsa_public_key.pem').toString('ascii');const privateKey = fs.readFileSync('./pem/rsa_private_key.pem').toString('ascii');console.log(publicKey, privateKey);const data = 'hi ryan suen';//const enData = crypto.publicEncrypt(publicKey, new Buffer(data)).toString('base64');const enData = crypto.publicEncrypt(publicKey, new Buffer(data));console.log( enData );//const deData = crypto.privateDecrypt( privateKey, new Buffer(enData, 'base64') );const deData = crypto.privateDecrypt( privateKey, enData );console.log(deData.toString());","categories":[],"tags":[]},{"title":"node.js 发现和解决问题","slug":"node-js-发现和解决问题","date":"2018-12-22T13:53:25.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/12/22/node-js-发现和解决问题/","link":"","permalink":"https://ryansuen.github.io/2018/12/22/node-js-发现和解决问题/","excerpt":"","text":"异常处理显示异常处理123456789101112function fn( name ) &#123; if( !name ) &#123; throw new Error(\"name is required!\"); &#125;&#125;//显示异常用try/catch处理try &#123; fn();&#125; catch( err ) &#123; console &amp;&amp; console.error( err.message, err.stack );&#125; ps: throw只能用于同步方法中。或者当异步方法中异步执行触发前 throw会生效。 通常抛出的异常都需要继承于Error。使用简单的字符串（new “ error”）无法获取对应的调用栈，无法获取那里发生错误的相关信息。 不要在内置的node.js方法中的回调函数中抛出异常；这样捕获到的堆栈没什么有用的信息。我们可以直接处理异常，或把异常交给合适的错误处理函数。 隐藏是异常123function fn(data) &#123; console.log(date); //ReferenceError： date is not defined&#125; try/catch 包住是很有必要的。 例如用try/catch包住JSON.parse也很有必要。 错误事件处理123var EventEmitter = require(\"events\").EventEmitter;var e = new EventEmitter();e.emit(\"error\", new Error(\"no handle to catch me\")); 处理方法 123e.on(\"error\", function(err) &#123; console &amp;&amp; console.error(err.message, err.stack);&#125;) 参数错误处理12345fs.readFile(\"./file.txt\", function(err, buf) &#123; if(err) &#123; return handleError(err); &#125;&#125;); 处理未捕获的异常12345678910var http = require(&quot;http&quot;);var server = http.createServer(req, res) &#123; response.end(&quot;hello world&quot;);&#125;;server.listen(3000);process.on(&quot;uncaughtException&quot;, function(err)&#123; console &amp;&amp; console.error(err); server.close(); setTimeout(process.exit, 500, 1);&#125;); 使用域来处理未捕获的异常123456789101112131415var domain = require(&quot;domain&quot;);var http = require(&quot;http&quot;);var d = domain.create();d.run(function() &#123; var server = http.createServer(req, res) &#123; d.on(&quot;error&quot;, function(err) &#123; res.statusCode = 500; res.end(&quot;internal server error&quot;); setTimeout(process.exit, 5000, 1); &#125;); response.end(&quot;hello world&quot;); &#125;; server.listen(3000);&#125;); node.js 的问题调试node debug123// test.jsvar a = 123;console.log(a); node debug test.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647➜ Desktop node debug test.js (node:78403) [DEP0068] DeprecationWarning: `node debug` is deprecated. Please use `node inspect` instead.&lt; Debugger listening on ws://127.0.0.1:9229/eaab7bad-ccd1-46d8-9e82-d5845e864dd7&lt; For help see https://nodejs.org/en/docs/inspector&lt; Debugger attached.Break on start in test.js:1&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 123; 2 console.log(a); 3 debug&gt; helprun, restart, r Run the application or reconnectkill Kill a running application or disconnectcont, c Resume executionnext, n Continue to next line in current filestep, s Step into, potentially entering a functionout, o Step out, leaving the current functionbacktrace, bt Print the current backtracelist Print the source around the current line where execution is currently pausedsetBreakpoint, sb Set a breakpointclearBreakpoint, cb Clear a breakpointbreakpoints List all known breakpointsbreakOnException Pause execution whenever an exception is thrownbreakOnUncaught Pause execution whenever an exception isn't caughtbreakOnNone Don't pause on exceptions (this is the default)watch(expr) Start watching the given expressionunwatch(expr) Stop watching an expressionwatchers Print all watched expressions and their current valuesexec(expr) Evaluate the expression and print the valuerepl Enter a debug repl that works like execscripts List application scripts that are currently loadedscripts(true) List all scripts (including node-internals)profile Start CPU profiling session.profileEnd Stop current CPU profiling session.profiles Array of completed CPU profiling sessions.profiles[n].save(filepath = 'node.cpuprofile') Save CPU profiling session to disk as JSON.takeHeapSnapshot(filepath = 'node.heapsnapshot') Take a heap snapshot and save to disk as JSON.debug&gt; ps: 如上方法已不推荐使用。 node inspect test.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546➜ Desktop node inspect test.js&lt; Debugger listening on ws://127.0.0.1:9229/e0ac6cc0-d7db-40ec-bd58-4d9a98f2a18f&lt; For help see https://nodejs.org/en/docs/inspector&lt; Debugger attached.Break on start in test.js:1&gt; 1 (function (exports, require, module, __filename, __dirname) &#123; var a = 123; 2 console.log(a); 3 debug&gt; helprun, restart, r Run the application or reconnectkill Kill a running application or disconnectcont, c Resume executionnext, n Continue to next line in current filestep, s Step into, potentially entering a functionout, o Step out, leaving the current functionbacktrace, bt Print the current backtracelist Print the source around the current line where execution is currently pausedsetBreakpoint, sb Set a breakpointclearBreakpoint, cb Clear a breakpointbreakpoints List all known breakpointsbreakOnException Pause execution whenever an exception is thrownbreakOnUncaught Pause execution whenever an exception isn&apos;t caughtbreakOnNone Don&apos;t pause on exceptions (this is the default)watch(expr) Start watching the given expressionunwatch(expr) Stop watching an expressionwatchers Print all watched expressions and their current valuesexec(expr) Evaluate the expression and print the valuerepl Enter a debug repl that works like execscripts List application scripts that are currently loadedscripts(true) List all scripts (including node-internals)profile Start CPU profiling session.profileEnd Stop current CPU profiling session.profiles Array of completed CPU profiling sessions.profiles[n].save(filepath = &apos;node.cpuprofile&apos;) Save CPU profiling session to disk as JSON.takeHeapSnapshot(filepath = &apos;node.heapsnapshot&apos;) Take a heap snapshot and save to disk as JSON.debug&gt; 感兴趣，自己尝试了。官方的推荐，但不够可视化。 使用Node inspector使用node-inspector $ npm install node-inspector -g 然后需要通过浏览器连接到node-inspector，需要启动inspector服务： $ node-inspector最后以debug模式运行node.js应用： 官文使用方法： 实际已不推荐。$ node --debug app.js ps: The node-debug command will load Node Inspector in your default browser. NOTE: Node Inspector works in Chrome and Opera only. You have to re-open the inspector page in one of those browsers if another browser is your default web browser (e.g. Safari or Internet Explorer). 建议使用Chrome为浏览器 实际使用：$ node --inspect app.js通过URL http://127.0.0.1:8080/debug?port=5858 就可以进行调试了。 1234#### 两个 node.js 服务自动重启工具推荐[supervisor](https://www.npmjs.com/package/supervisor) npm install -g supervisor //使用supervisor ./app.js12[nodemon](https://www.npmjs.com/package/nodemon) npm install -g nodemon //使用nodemon ./app.js`","categories":[],"tags":[]},{"title":"简单的apm性能收集方案","slug":"简单的apm性能收集方案","date":"2018-12-04T02:21:42.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/12/04/简单的apm性能收集方案/","link":"","permalink":"https://ryansuen.github.io/2018/12/04/简单的apm性能收集方案/","excerpt":"","text":"原理本文通过浏览器提供的performance接口获取页面性能数据。performace相关的了解请查看performance。 整体技术方案 浏览器上报sdk添加性能收集部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113_performance: function (config) &#123; var performance = window.performance; if (!!performance) &#123; var data = &#123;&#125;; data.origin_pathname = location.origin + location.pathname; if (performance.memory) &#123; data.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit; data.totalJSHeapSize = performance.memory.totalJSHeapSize; data.usedJSHeapSize = performance.memory.usedJSHeapSize; if ( data.jsHeapSizeLimit === 0 || data.totalJSHeapSize === 0 || data.usedJSHeapSize === 0 ) &#123; return false; &#125; &#125; if (performance.navigation) &#123; data.redirectCount = performance.navigation.redirectCount; data.type = performance.navigation.type; &#125; // if(performance.timeOrigin) &#123; // data.timeOrigin = performance.timeOrigin; // &#125; if (!!performance.timing) &#123; var navigationStart = performance.timing.navigationStart; var redirectStart = performance.timing.redirectStart; var redirectEnd = performance.timing.redirectEnd; var fetchStart = performance.timing.fetchStart; var domainLookupStart = performance.timing.domainLookupStart; var domainLookupEnd = performance.timing.domainLookupEnd; var connectStart = performance.timing.connectStart; var secureConnectionStart = performance.timing.secureConnectionStart; var connectEnd = performance.timing.connectEnd; var requestStart = performance.timing.requestStart; var responseStart = performance.timing.responseStart; var responseEnd = performance.timing.responseEnd; var domLoading = performance.timing.domLoading; var domInteractive = performance.timing.domInteractive; var domContentLoadedEventStart = performance.timing.domContentLoadedEventStart; var domContentLoadedEventEnd = performance.timing.domContentLoadedEventEnd; var domComplete = performance.timing.domComplete; var loadEventStart = performance.timing.loadEventStart; var loadEventEnd = performance.timing.loadEventEnd; var unloadEventStart = performance.timing.unloadEventStart; var unloadEventEnd = performance.timing.unloadEventEnd; data.appCache = Math.max(domainLookupStart - fetchStart, 0); data.dns = domainLookupEnd - domainLookupStart; data.connection = connectEnd - connectStart; data.request = responseStart - requestStart; data.response = responseEnd - responseStart; data.loading = responseEnd - requestStart; data.rendering = domComplete - domLoading; data.blankScreen = domContentLoadedEventEnd - navigationStart; data.domComplete = domComplete - navigationStart; data.loaded = loadEventEnd - navigationStart; data.loadEvent = loadEventEnd - loadEventStart; if ( data.appCache &lt; 0 || data.appCache &gt; 120000 || data.dns &lt; 0 || data.dns &gt; 120000 || data.connection &lt; 0 || data.connection &gt; 120000 || data.request &lt; 0 || data.request &gt; 120000 || data.loading &lt; 0 || data.loading &gt; 120000 || data.rendering &lt; 0 || data.rendering &gt; 120000 || data.blankScreen &lt; 0 || data.blankScreen &gt; 120000 || data.domComplete &lt; 0 || data.domComplete &gt; 120000 || data.loaded &lt; 0 || data.loaded &gt; 120000 || data.loadEvent &lt; 0 || data.loadEvent &gt; 120000 ) &#123; return false; &#125; &#125; try &#123; var origin = config.url.split('/api'); var url = origin[0] + '/api/apm/performance'; this.request.ajax(&#123; url: url || 'https://xxx.xxx.com/api/apm/performance', type: 'post', data: data, success: function (res) &#123; //do nothing &#125; &#125;); &#125; catch (e) &#123; console &amp;&amp; console.error(JSON.stringify(e)); &#125; &#125; &#125;, 如上代码我们注意如几个点： performance有兼容性问题存在，所以要先判断浏览器是否已支持。 内存数据可能回有异常，如jsHeapSizeLimit=0。存在异常数据可过滤掉本条数据。 性能数据每一条都可能有异常值，导致计算出来的差值可能小于零，也可能很大。这里做了一个正常值判断。0&lt;=正常数据&lt;=120,000ms。 服务器接性能数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081post: async (ctx, next) =&gt; &#123; try &#123; let reqQuery = ctx.request.body; let queryData = &#123; origin_pathname: reqQuery['origin_pathname'], jsHeapSizeLimit: reqQuery['jsHeapSizeLimit'], totalJSHeapSize: reqQuery['totalJSHeapSize'], usedJSHeapSize: reqQuery['usedJSHeapSize'], redirectCount: reqQuery['redirectCount'], type: reqQuery['type'], redirect: reqQuery['redirect'], appCache: reqQuery['appCache'], dns: reqQuery['dns'], connection: reqQuery['connection'], request: reqQuery['request'], response: reqQuery['response'], loading: reqQuery['loading'], rendering: reqQuery['rendering'], blankScreen: reqQuery['blankScreen'], domComplete: reqQuery['domComplete'], loaded: reqQuery['loaded'], loadEvent: reqQuery['loadEvent'], create_time: moment().unix(), &#125;; if ( queryData.appCache &lt; 0 || queryData.appCache &gt; 120000 || queryData.dns &lt; 0 || queryData.dns &gt; 120000 || queryData.connection &lt; 0 || queryData.connection &gt; 120000 || queryData.request &lt; 0 || queryData.request &gt; 120000 || queryData.response &lt; 0 || queryData.response &gt; 120000 || queryData.loading &lt; 0 || queryData.loading &gt; 120000 || queryData.rendering &lt; 0 || queryData.rendering &gt; 120000 || queryData.blankScreen &lt; 0 || queryData.blankScreen &gt; 120000 || queryData.domComplete &lt; 0 || queryData.domComplete &gt; 120000 || queryData.loaded &lt; 0 || queryData.domComplete &gt; 120000 || queryData.loadEvent &lt; 0 || queryData.loadEvent &gt; 120000 || queryData.jsHeapSizeLimit == 0 || isNaN(queryData.jsHeapSizeLimit) || queryData.totalJSHeapSize == 0 || isNaN(queryData.totalJSHeapSize) || queryData.usedJSHeapSize == 0 || isNaN(queryData.usedJSHeapSize) ) &#123; ctx.response.body = repWrapper(&#123; status: \"OK\", info: '不合理数据,暂不做统计' &#125;) return; &#125; let status = await new Promise((resolve, reject) =&gt; &#123; // rdsCli.keys('performance:*', function (err, keys) &#123; // let len = keys.length; // if (len &lt; 10416) &#123; //日300w pv 平均每5分钟的pv数 rdsCli.set(`performance:$&#123;utils.guid()&#125;`, JSON.stringify(queryData), 'EX', (70), function (err, status) &#123; if (err) &#123; reject(err); throw err; &#125; else &#123; resolve(&#123; status &#125;); &#125; &#125;); // &#125; else &#123; // resolve(&#123; // status: \"OK\", // info: '达到设定的redis缓存上线，不做redis缓存处理' // &#125;); // &#125; // &#125;); &#125;); ctx.response.body = repWrapper(status) &#125; catch (e) &#123; ctx.response.body = repWrapper(e.toString(), errMapping['ERR_DATABASE_REQ']['code']); throw e; &#125; &#125; 此部分将数据缓存到redis70s。同理这里也做了一些数据校验，过滤掉无用的数据。 定时任务获取redis中的数据并入库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647module.exports = async () =&gt; &#123; let data = await new Promise((resolve, reject) =&gt; &#123; rdsCli.keys('performance:*', async function (err, keys) &#123; let data = await bluebird.map(keys, async (v, k) =&gt; &#123; let value = await getAsync(v); return JSON.parse( value ); &#125;); _.map(keys, (key) =&gt; &#123; rdsCli.set(key, '', 'EX', 1); &#125;); resolve(data); &#125;); &#125;); //计算 let archive = _.groupBy(data, 'origin_pathname'); let archiveData = Object.keys(archive).map((v) =&gt; &#123; return archive[v].reduce((a, b) =&gt; &#123; let temp = &#123;&#125;; _.keys(a).forEach((sv) =&gt; &#123; if ('origin_pathname' === sv) &#123; temp[sv] = a[sv]; &#125; else if( 'create_time' === sv ) &#123; temp[sv] = Math.round( ( parseFloat(a[sv]) + parseFloat(b[sv]) ) / 2) &#125; else &#123; temp[sv] = ( ( parseFloat(a[sv]) + parseFloat(b[sv]) ) / 2).toFixed(2); &#125; &#125;); return temp; &#125;) &#125;); archiveData = archiveData.filter((v) =&gt; &#123; return v.jsHeapSizeLimit != 'NaN' &amp;&amp; v.totalJSHeapSize != 'NaN' &amp;&amp; v.usedJSHeapSize != 'NaN' &amp;&amp; v.domComplete != 'NaN' &amp;&amp; v.loadEvent != 'NaN'; &#125;); //批量插入数据库 let queryRst = await db.elPerformance.bulkCreate(archiveData); &#125; 几个需要注意的点 从redis拿数据是30秒一次。而redis的缓存是70秒，所以拿到redis数据后，需要将已经拿到的数据删除，以防出现重复数据。 这里做的不好的点从redis拿出的数据校验不够完善，需优化。 获取性能数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117get: async (ctx, next) =&gt; &#123; try &#123; // 取参 let &#123; origin_pathname, start_time, end_time &#125; = ctx.query; // 查询 let whereQuery = &#123;&#125;; const Op = db.sequelize.Op; if (origin_pathname) &#123; whereQuery['origin_pathname'] = &#123; [Op.like]: `%$&#123;origin_pathname&#125;%` &#125;; &#125; if (start_time &amp;&amp; end_time) &#123; whereQuery['create_time'] = &#123; $gt: start_time, $lt: end_time &#125;; &#125; let queryRst = await db.elPerformance.findAndCountAll(&#123; attributes: [ db.sequelize.fn('DISTINCT', db.sequelize.col('origin_pathname')), ], where: whereQuery, raw: true &#125;); // 返回 ctx.response.body = repWrapper(&#123; list: queryRst.rows, page: &#123; current: 1 || current, per_page: 15 || per_page, total_page: 15 || Math.ceil(queryRst.count.length / per_page) &#125; &#125;); &#125; catch (e) &#123; ctx.response.body = repWrapper(e.toString(), errMapping['ERR_DATABASE_REQ']['code']); throw e; &#125; &#125;, one: async (ctx, next) =&gt; &#123; let origin_pathname = decodeURIComponent(ctx.params.id); try &#123; // 取参 let &#123; start_time, end_time, &#125; = ctx.query; // 查询 let whereQuery = &#123;&#125;; whereQuery['origin_pathname'] = origin_pathname; if (start_time &amp;&amp; end_time) &#123; whereQuery['create_time'] = &#123; $gt: start_time, $lt: end_time &#125;; &#125; let queryDetail = await db.elPerformance.findAndCountAll(&#123; attributes: [ 'connection', 'request', 'response', 'loading', 'rendering', 'blankScreen', 'domComplete', 'loaded', 'loadEvent', 'create_time' ], where: whereQuery &#125;); let qdf = &#123; 'connection': [], 'request': [], 'response': [], 'loading': [], 'rendering': [], 'blankScreen': [], 'domComplete': [], 'loaded': [], 'loadEvent': [], 'create_time': [] &#125;; queryDetail.rows.forEach((v) =&gt; &#123; let data = v.dataValues; Object.keys(data).forEach( sv =&gt; &#123; if( 'create_time'=== sv ) &#123; qdf[sv].push( moment.unix(v[sv]).format(\"YYYY-MM-DD hh:MM:SS\") ); &#125; else &#123; qdf[sv].push(v[sv]); &#125; &#125;); &#125;); // 返回 ctx.response.body = repWrapper(&#123; origin_pathname, queryDetail: qdf, count: queryDetail.count, &#125;); &#125; catch (e) &#123; ctx.response.body = repWrapper(e.toString(), errMapping['ERR_DATABASE_REQ']['code']); throw e; &#125; &#125;, 这一步就很简单了，先获取列表的数据，再获取具体某一条链接的性能数据。这里也有几个注意点 默认设置的查询时间比较短（一天） 没有一次性计算完所有页面的数据，计算量太大，假设每条连接每天有8000条数据，500条链接总共就会有4000万条数据，数据砍半也有2000万条数据。很好性能。所以改成了如上的查询方式。 对某些数据字段添加了索引（id, origin_path, create_at），加速查询。 后台界面展示 列表页 具体性能页面","categories":[],"tags":[]},{"title":"github之webhook自动部署","slug":"github之webhook自动部署","date":"2018-10-21T00:36:49.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/10/21/github之webhook自动部署/","link":"","permalink":"https://ryansuen.github.io/2018/10/21/github之webhook自动部署/","excerpt":"","text":"技术应用场景 自己有一个小的技术博客，部分代码用github托管， 含有隐私信息的代码采用了ftp上传绕过托管。当然更好的方式是自己搭建一个gitlab服务器。代码部署在自己的服务器上面，每次提交完代码都要去服务器上面更新代码是一件很低效的事。说以想通通过一个性价比很高的方式实现如上需求。 原理 配置GitHub当push master上代码的时候，访问自己服务器上的一个api（webhooks），假如叫https://xxx.com/api/webhook。https://xxx.com/ api里写着这样的逻辑，拉取代码（git fetch）, 合并代码(git merge）。 自己玩也就没有做打标签。 代码拉取，合并完毕，重启服务端的服务，我是用了pm2做进程管理，所以再执行pm2 restart name就好。 原理很简单，就是当向github里push master代码的时候，github调用服务器的api，服务器拉取，合并代码，然后重启网站服务。 github配置 进入对应的仓库 点击settings 点击Webhooks add webhooks Payload URL 里添加好我们自己服务器的完整api url。 Which events would you like to trigger this webhook? 选Just the push event.就好。 服务端代码(node.js)1234567891011121314151617181920//这里使用了shelljs模块，实现js和linux的交互。async function linux(command) &#123; return await new Promise((resolve, reject) =&gt; &#123; shell.exec(`$&#123;command&#125;`, (err, stdout, srderr) =&gt; &#123; if(err) &#123; reject(srderr); &#125; else &#123; resolve(stdout); &#125; &#125;); &#125;);&#125;//......//怎么实现一个nodejs就不赘述了// 此处异步改同步后的操作（本api的返回，发送新的请求）都不行。let fetch = await utils.linux('git fetch origin');let merge = await utils.linux('git merge origin/master');let pm2 = await utils.linux('pm2 restart ryansuen.top'); 这里我做了当服务器完成代码拉取，合并后就钉钉推送的操作。 但无论我用shelljs的回调还是通过async/await改异步为同步都不行代码都不能正常运行。(想拿到shelljs执行linux命令返回的信息，再钉钉通知，方便知晓是否成功) 这里我做了个调整，api的第一步是做钉钉通知，后面在做拉取，合并操作。 这样操作注意访问线上代码是否生效。 这里我只是满足，我自己的一台服务器的提效需求。而且还有一些安全问题目前还没有进一步完善。哪些问题呢？ 如果有多台服务器怎么操作？ (发布机) 其他人知道我的跟新api url怎么办？(代码执行用户，文件权限，访问的ip限制) 目前博客主要是满足自己提升需求，遭受攻击的风险还小，未做更多的安全操作。","categories":[],"tags":[]},{"title":"node.js爬虫实战一例","slug":"node-js爬虫实战一例","date":"2018-08-30T16:06:10.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/08/31/node-js爬虫实战一例/","link":"","permalink":"https://ryansuen.github.io/2018/08/31/node-js爬虫实战一例/","excerpt":"","text":"爬虫实战一例爬虫需求由来我的目的很单纯，只是想知道这个小测试背后的测试结果数据，看能不能获取到一些有用的信息。 分析通过观察，我们会发现结果页的数据很少，然而就这样简简单单的几个数据就形成了一个完整的结果，还能产生一定的传播效应。接下来开始我们一探究竟。 切入点通过chrome我们很容易发现，这不是一个后端渲染的页面，我们不需要去爬完整的页面，再渲染页面，然后通过造作dom获取数据。我们也能够很容易能够发现他的数据来自于哪一个接口。接口是https://www.goodstudydayup.com:1443/wnl/H5Test/nameresult?tid=25&amp;name=%E6%B5%8B%E8%AF%95&amp;op=0。 通过肉眼观察，我们发现这个接口有如下3个参数： tid=25 name=%E6%B5%8B%E8%AF%95 op=0 open in new tab,返回的数据如下：123456789101112&#123; code: \"200\", msg: \"ok\", data: &#123; title: \"赵丽颖\", placehold: \"的命运相似明星是\", icon: \"https://cdn.jptj.goodstudydayup.com/cover/201807/1532503163444.jpeg\", point: \"6\", desc: \"你的命运和赵丽颖相似，喜欢脚踏实地的前进，独一无二的你总有一天能够功成名就，实现自己的梦想。\", back_small: \"https://cdn.jptj.goodstudydayup.com/cover/201807/1532502774491.jpeg\" &#125;&#125; 看到这里心中暗喜了下，才三个参数，那应该很好猜，name我们一看便知道是什么。用户的名字。那tid和op代表什么意思呢？ tid和op估计是猜不出来，我们不试一试。初高中大学我们都做过实验，知道要去探究某一个输入（参数）对响应（返回值）有什么影响。只要改变这一项输入的值，保证其他输入不变。 我们先从op开始验证,只改变链接上的op值。\b\b从链接看op是一个整数，我们用不同的整数验证。 op(输入) response(响应) 0 title: “赵丽颖” -1 title: “吴彦祖”, 1 title: “吴彦祖”, 2 title: “吴彦祖”, … … 看到这里大概有点\b\b眉目了，我们先不做结论。继续往下验证两种情况。op为0与改变name，op为1\b改变name值,op为-1改变\bname值。 op(输入) name(输入) response(响应) 0 测试 title: “赵丽颖” 0 测试1 title: “宋慧乔” 0 测试2 title: “小S” 0 测试3 title: “赵丽颖” … … … op(输入) name(输入) response(响应) 1 测试 title: “吴彦祖” 1 测试1 title: “杨洋” 1 测试2 title: “林更新” 1 测试3 title: “林更新” … … … op(输入) name(输入) response(响应) -1 测试 title: “吴彦祖” -1 测试1 title: “杨洋” -1 测试2 title: “林更新” -1 测试3 title: “林更新” … … … 看完\b上面的结果我们基本可以得出结论。op\b原来代表性别。1是男性，0是女性（他自己定的值，不用去质疑）。\b\b其他整数默认为男性。 这里我们可以很自然的想到一个疑问，\b\b\b为什么性别这个参数它\b没有\b命名为sex 或则gender,而是op? 我们可以猜测下，op\b（option?）,难道不一定代表性别？\b先放下这个疑问不管。\b继续往下探索。 name,op我们都大概清晰了，\b\b接下来就是去研究tid代表什么意思了？\b老规矩，tid改变，其它值不变。tid初始值等于25,我们取前10条数据的结果看看。 通过代码获取结果数据12345678910(async () =&gt; &#123; Array.from(new Array(30),(val,index)=&gt;index).forEach(async(v,k) =&gt; &#123; let tid = v; let name = '测试'; let op = 0; let reptileUrl = `https://www.goodstudydayup.com:1443/wnl/H5Test/nameresult?tid=$&#123;tid&#125;&amp;name=$&#123;name&#125;&amp;op=$&#123;op&#125;`; let res = await superagent.get(reptileUrl); console.log(tid, res.text); &#125;);&#125;)(); \b数据结果1234567891011121314151617181920212223242526272829303 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'2 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'4 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'1 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'7 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'9 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"锄头一把\",\"placehold\":\"的名字价值\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201805/1526372362583.jpeg\",\"point\":\"2,5,8\",\"desc\":\"虽说低调是美德，但你的名字可能就显得有点不讲究了，对事业的帮助率很低。赶紧想想如何提升自己名字的价值吧！\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'6 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'5 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'10 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"德国\",\"placehold\":\"的最佳旅行地是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201805/1526376399512.jpeg\",\"point\":\"2,15\",\"desc\":\"你拥有敢于冒险的勇气，做任何事情都会精细研究，提前做好规划，一步一步完成，所以有计划的旅行更适合你哦！\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'12 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'15 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"晴\",\"placehold\":\"的性格天气是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201805/1526977505571.jpeg\",\"point\":\"1,2,3\",\"desc\":\"晴天代表你乐观开朗，内心充满阳光，这样的你，面对工作和生活时，你也能保持不错的精神状态。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'11 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'22 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"竞争对手\",\"placehold\":\"与爱人的前世关系是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201806/1529996973828.jpeg\",\"point\":\"2\",\"desc\":\"前世的你们是互相竞争的对手，今世的你们惺惺相惜，彼此的牵绊会很深，感情也会越来越深厚。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201806/1529996467162.jpeg\"&#125;&#125;'14 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'20 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'18 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'17 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'0 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'19 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'16 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"1\",\"placehold\":\"1\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201805/1527146243892.jpeg\",\"point\":\"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16\",\"desc\":\"11\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'8 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'23 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"28岁\",\"placehold\":\"的暴富年龄段是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1530521690641.jpeg\",\"point\":\"2\",\"desc\":\"你自身对于金钱很是敏感，知道自己应该投资什么来快速获取利润，所以赚钱相对容易，而且后面会财源不断。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1530521141284.jpeg\"&#125;&#125;'13 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;'24 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"宫保鸡丁\",\"placehold\":\"的个性代表菜是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1531210375761.jpeg\",\"point\":\"2\",\"desc\":\"色调鲜艳、香辣味浓，吃起来肉质滑嫩。如你一般，让人满心欢喜，回味悠长。简而言之，你的天生属性就是招人疼。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1531209184727.jpeg\"&#125;&#125;'25 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"林志玲\",\"placehold\":\"的命运相似明星是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1532503163593.jpeg\",\"point\":\"2\",\"desc\":\"你的气质宛若林志玲一般充满大家闺秀的气息，而你的命运也似乎和她一样，只要你和她一样有颗坚韧的心，成功指日可待。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201807/1532502774491.jpeg\"&#125;&#125;'26 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"雅典娜\",\"placehold\":\"的守护神是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1533635829116.jpeg\",\"point\":\"2\",\"desc\":\"你像智慧女神一样，是最聪明的女神，是智慧和力量的完美结合，你代表着女性的力量，眼神明亮，性格开朗。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1533634370304.jpeg\"&#125;&#125;'29 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"锦觅\",\"placehold\":\"的角色是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1535441155154.jpeg\",\"point\":\"1,2\",\"desc\":\"你向来是一个天真烂漫的人，为朋友可以两肋插刀，不管对待生活还是感情都有一腔赤诚，哪怕受伤都在所不惜。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1535440988818.jpeg\"&#125;&#125;'27 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"纯妃\",\"placehold\":\"的角色是\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1534230311231.jpeg\",\"point\":\"2,10\",\"desc\":\"你在生活中言不由衷，喜欢带着面具的人，对于生活中你所需要的东西，你会竭尽全力的去做并得到它。\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201808/1534227874391.jpeg\"&#125;&#125;'21 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"title\":\"偏财运欠佳\",\"placehold\":\"的下半年\",\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/201806/1528267891823.jpeg\",\"point\":\"2\",\"desc\":\"你下半年偏财运也不大好哦，所以还是把精力用在正财上面吧，好好工作，才会有满意的回报！\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/201806/1528267523938.jpeg\"&#125;&#125;'28 '&#123;\"code\":\"200\",\"msg\":\"ok\",\"data\":&#123;\"icon\":\"https://cdn.jptj.goodstudydayup.com/cover/\",\"back_small\":\"https://cdn.jptj.goodstudydayup.com/cover/\"&#125;&#125;' \b分析数据,我们很容易发现并不是所有的tid都能获得有效数据。\btid为9的结果数据有效。 \b[有效数据]\b\b.data.title 会有值。\b通过\b代码找到有效的tid. 123456789101112131415if(true) &#123; (async () =&gt; &#123; Array.from(new Array(1000),(val,index)=&gt;index).forEach(async(v,k) =&gt; &#123; let tid = v; let name = '测试'; let op = 0; let reptileUrl = `https://www.goodstudydayup.com:1443/wnl/H5Test/nameresult?tid=$&#123;tid&#125;&amp;name=$&#123;name&#125;&amp;op=$&#123;op&#125;`; let res = await superagent.get(reptileUrl); res = JSON.parse(res.text); if(res.data.title) &#123; console.log(tid); &#125; &#125;); &#125;)();&#125; //\b获取到的\b有效值如下：12345678910111216222410252792921232615 到此我们三个参数我们全部我们全部明白了。 \b\btid: [9,10, 15, 16,21,22,23,24,25,26,27, 29] op: [0,1] name: * \b经过如上的分析，我们\b可以\b正式开始\b\b为所欲为的爬数据了。1234567891011121314151617181920212223242526272829303132333435363738394041424344if(false) &#123; let name = '子义'; let tids = [9,10, 15, 16,21,22,23,24,25,26,27, 29]; tids.forEach(async (tid) =&gt; &#123; [0,1].forEach(async (op) =&gt; &#123; try &#123; let reptileUrl = `https://www.goodstudydayup.com:1443/wnl/H5Test/nameresult?tid=$&#123;tid&#125;&amp;name=$&#123;name&#125;&amp;op=$&#123;op&#125;`; let r1 = await superagent.get(reptileUrl); let o1 = JSON.parse(r1.text); if (o1.data.title) &#123; //let flag = await db.Wnl.find(&#123; 'data.title': o1.data.title &#125;); //if ( flag.length === 0 ) &#123; o1.data.tid = tid; o1.data.op = op; o1.data.name = name; db.Wnl.create(o1); let names = [ '梦琪', '之桃', '慕青', '尔岚', '初夏', '沛菡', '傲珊', '曼文', '乐菱', '惜文', '香寒', '新柔', '语蓉', '海安', '夜蓉', '涵柏', '水桃', '醉蓝', '语琴', '从彤', '傲晴', '语兰', '又菱', '碧彤', '元霜', '怜梦', '紫寒', '妙彤', '曼易', '南莲', '紫翠', '雨寒', '易烟', '如萱', '若南', '寻真', '晓亦', '向珊', '慕灵', '以蕊', '映易', '雪柳', '海云', '凝天', '沛珊', '寒云', '冰旋', '宛儿', '绿真', '晓霜', '碧凡', '夏菡', '曼香', '若烟', '半梦', '雅绿', '冰蓝', '灵槐', '平安', '书翠', '翠风', '代云', '梦曼', '幼翠', '听寒', '梦柏', '醉易', '访旋', '亦玉', '凌萱', '访卉', '怀亦', '笑蓝', '靖柏', '夜蕾', '冰夏', '梦松', '书雪', '乐枫', '念薇', '靖雁', '从寒', '觅波', '静曼', '凡旋', '以亦', '念露', '芷蕾', '千兰', '新波', '代真', '新蕾', '雁玉', '冷卉', '紫山', '千琴', '傲芙', '盼山', '怀蝶', '冰兰', '山柏', '翠萱', '问旋', '白易', '问筠', '如霜', '半芹', '丹珍', '冰彤', '亦寒', '之瑶', '冰露', '尔珍', '谷雪', '乐萱', '涵菡', '海莲', '傲蕾', '青槐', '易梦', '惜雪', '宛海', '之柔', '夏青', '亦瑶', '妙菡', '紫蓝', '幻柏', '元风', '冰枫', '访蕊', '芷蕊', '凡蕾', '凡柔', '安蕾', '天荷', '含玉', '书兰', '雅琴', '书瑶', '从安', '夏槐', '念芹', '代曼', '幻珊', '谷丝', '秋翠', '白晴', '海露', '代荷', '含玉', '书蕾', '听白', '灵雁', '雪青', '乐瑶', '含烟', '涵双', '平蝶', '雅蕊', '傲之', '灵薇', '含蕾', '从梦', '从蓉', '初丹。听兰', '听蓉', '语芙', '夏彤', '凌瑶', '忆翠', '幻灵', '怜菡', '紫南', '依珊', '妙竹', '访烟', '怜蕾', '映寒', '友绿', '冰萍', '惜霜', '凌香', '芷蕾', '雁卉', '迎梦', '元柏', '代萱', '紫真', '千青', '凌寒', '紫安', '寒安', '怀蕊', '秋荷', '涵雁', '以山', '凡梅', '盼曼', '翠彤', '谷冬', '冷安', '千萍', '冰烟', '雅阳', '友绿', '南松', '诗云', '飞风', '寄灵', '书芹', '幼蓉', '以蓝', '笑寒', '忆寒', '秋烟', '芷巧', '水香', '映之', '醉波', '幻莲', '夜山', '芷卉', '向彤', '小玉', '幼南', '凡梦', '尔曼', '念波', '迎松', '青寒', '笑天', '涵蕾', '碧菡', '映秋', '盼烟', '忆山', '以寒', '寒香', '小凡', '代亦', '梦露', '映波', '友蕊', '寄凡', '怜蕾', '雁枫', '水绿', '曼荷', '笑珊', '寒珊', '谷南', '慕儿', '夏岚', '友儿', '小萱', '紫青', '妙菱', '冬寒', '曼柔', '语蝶', '青筠', '夜安', '觅海', '问安', '晓槐', '雅山', '访云', '翠容', '寒凡', '晓绿', '以菱', '冬云', '含玉', '访枫', '含卉', '夜白', '冷安', '灵竹', '醉薇', '元珊', '幻波', '盼夏', '元瑶', '迎曼', '水云', '访琴', '谷波', '笑白', '妙海', '紫霜', '凌旋', '孤丝', '怜寒', '凡松', '青丝', '翠安', '如天', '凌雪', '绮菱', '代云', '香薇', '冬灵', '凌珍', '沛文', '紫槐', '幻柏', '采文', '雪旋', '盼海', '映梦', '安雁', '映容', '凝阳', '访风', '天亦', '觅风', '小霜', '雪萍', '半雪', '山柳', '谷雪', '靖易', '白薇', '梦菡', '飞绿', '如波', '又晴', '友易', '香菱', '冬亦', '问雁', '海冬', '秋灵', '凝芙', '念烟', '白山', '从灵', '尔芙', '迎蓉', '念寒', '翠绿', '翠芙', '靖儿', '妙柏', '千凝', '小珍', '妙旋', '雪枫', '夏菡', '绮琴', '雨双', '听枫', '觅荷', '凡之', '晓凡', '雅彤', '孤风', '从安', '绮彤', '之玉', '雨珍', '幻丝', '代梅', '青亦', '元菱', '海瑶', '飞槐', '听露', '梦岚', '幻竹', '谷云', '忆霜', '水瑶', '慕晴', '秋双', '雨真', '觅珍', '丹雪', '元枫', '思天', '如松', '妙晴', '谷秋', '妙松', '晓夏', '宛筠', '碧琴', '盼兰', '小夏', '安容', '青曼', '千儿', '寻双', '涵瑶', '冷梅', '秋柔', '思菱', '醉波', '醉柳', '以寒', '迎夏', '向雪', '以丹', '依凝', '如柏', '雁菱', '凝竹', '宛白', '初柔', '南蕾', '书萱', '梦槐', '南琴', '绿海', '沛儿', '晓瑶', '凝蝶', '紫雪', '念双', '念真', '曼寒', '凡霜', '飞雪', '雪兰', '雅霜', '从蓉', '冷雪', '靖巧', '翠丝', '觅翠', '凡白', '乐蓉', '迎波', '丹烟', '梦旋', '书双', '念桃', '夜天', '安筠', '觅柔', '初南', '秋蝶', '千易', '安露', '诗蕊', '山雁', '友菱', '香露', '晓兰', '白卉', '语山', '冷珍', '秋翠', '夏柳', '如之', '忆南', '书易', '翠桃', '寄瑶', '如曼', '问柳', '幻桃', '又菡', '醉蝶', '亦绿', '诗珊', '听芹', '新之', '易巧', '念云', '晓灵', '静枫', '夏蓉', '如南', '幼丝', '秋白', '冰安', '秋白', '南风', '醉山', '初彤', '凝海', '紫文', '凌晴', '雅琴', '傲安', '傲之', '初蝶', '代芹', '诗霜', '碧灵', '诗柳', '夏柳', '采白', '慕梅', '乐安', '冬菱', '紫安', '宛凝', '雨雪', '易真', '安荷', '静竹', '代柔', '丹秋', '绮梅', '依白', '凝荷', '幼珊', '忆彤', '凌青', '之桃', '芷荷', '听荷', '代玉', '念珍', '梦菲', '夜春', '千秋', '白秋', '谷菱', '飞松', '初瑶', '惜灵', '梦易', '新瑶', '曼梅', '碧曼', '友瑶', '雨兰', '夜柳', '芷珍', '含芙', '夜云', '依萱', '凝雁', '以莲', '安南', '幼晴', '尔琴', '飞阳', '白凡', '沛萍', '雪瑶', '向卉', '采文', '乐珍', '寒荷', '觅双', '白桃', '安卉', '迎曼', '盼雁', '乐松', '涵山', '问枫', '以柳', '含海', '翠曼', '忆梅', '涵柳', '海蓝', '晓曼', '代珊', '忆丹', '静芙', '绮兰', '梦安', '紫丝', '千雁', '凝珍', '香萱', '梦容', '冷雁', '飞柏', '天真', '翠琴', '寄真', '秋荷', '代珊', '初雪', '雅柏', '怜容', '如风', '南露', '紫易', '冰凡', '海雪', '语蓉', '碧玉', '语风', '凝梦', '从雪', '白枫', '傲云', '白梅', '念露', '慕凝', '雅柔', '盼柳', '半青', '从霜', '怀柔', '怜晴', '夜蓉', '代双', '以南', '若菱', '芷文', '南晴', '梦寒', '初翠', '灵波', '问夏', '惜海', '亦旋', '沛芹', '幼萱', '白凝', '初露', '迎海', '绮玉', '凌香', '寻芹', '秋柳', '尔白', '映真', '含雁', '寒松', '寻雪', '青烟', '问蕊', '灵阳', '雪巧', '丹萱', '凡双', '孤萍', '紫菱', '寻凝', '傲柏', '傲儿', '友容', '灵枫', '尔丝', '曼凝', '若蕊', '问丝', '思枫', '水卉', '问梅', '念寒', '诗双', '翠霜', '夜香', '寒蕾', '凡阳', '冷玉', '平彤', '语薇', '幻珊', '紫夏', '凌波', '芷蝶', '丹南', '之双', '凡波', '思雁', '白莲', '从菡', '如容', '采柳', '沛岚', '惜儿', '夜玉', '水儿', '半凡', '语海', '听莲', '幻枫', '念柏', '冰珍', '思山', '凝蕊', '天玉', '思萱', '向梦', '笑南', '夏旋', '之槐', '元灵', '以彤', '采萱', '巧曼', '绿兰', '平蓝', '问萍', '绿蓉', '靖柏。迎蕾', '碧曼', '思卉', '白柏', '妙菡', '怜阳', '雨柏', '雁菡', '梦之', '又莲', '乐荷', '寒天', '凝琴', '书南', '映天', '白梦', '初瑶', '平露', '含巧', '慕蕊', '半莲', '醉卉', '天菱', '青雪', '雅旋', '巧荷', '飞丹', '若灵', '尔云', '幻天', '诗兰', '青梦', '海菡', '灵槐', '忆秋', '寒凝', '凝芙', '绮山', '静白', '尔蓉', '尔冬', '映萱', '白筠', '冰双', '访彤', '绿柏', '夏云', '笑翠', '晓灵', '含双', '盼波', '以云', '怜翠', '雁风', '之卉', '平松', '问儿', '绿柳', '如蓉', '曼容', '天晴', '丹琴', '惜天', '寻琴', '依瑶', '涵易', '忆灵', '从波', '依柔', '问兰', '山晴', '怜珊', '之云', '飞双', '傲白', '沛春', '雨南', '梦之', '笑阳', '代容', '友琴', '雁梅', '友桃', '从露', '语柔', '傲玉', '觅夏', '晓蓝', '新晴', '雨莲', '凝旋', '绿旋', '幻香', '觅双', '冷亦', '忆雪', '友卉', '幻翠', '靖柔', '寻菱', '丹翠', '安阳', '雅寒', '惜筠', '尔安', '雁易', '飞瑶', '夏兰', '沛蓝', '静丹', '山芙', '笑晴', '新烟', '笑旋', '雁兰', '凌翠', '秋莲', '书桃', '傲松', '语儿', '映菡', '初曼', '听云', '初夏', '雅香', '语雪', '初珍', '白安', '冰薇', '诗槐', '冷玉', '冰巧', '之槐', '夏寒', '诗筠', '新梅', '白曼', '安波', '从阳', '含桃', '曼卉', '笑萍', '晓露', '寻菡', '沛白', '平灵', '水彤', '安彤', '涵易', '乐巧', '依风', '紫南', '亦丝', '易蓉', '紫萍', '惜萱', '诗蕾', '寻绿', '诗双', '寻云', '孤丹', '谷蓝', '山灵', '幻丝', '友梅', '从云', '雁丝', '盼旋', '幼旋', '尔蓝', '沛山', '代丝', '觅松', '冰香', '依玉', '冰之', '妙梦', '以冬', '曼青', '冷菱', '雪曼', '安白', '千亦', '凌蝶', '又夏', '南烟。靖易', '沛凝', '翠梅', '书文', '雪卉', '乐儿', '傲丝', '安青', '初蝶', '寄灵', '惜寒', '雨竹', '冬莲', '绮南', '翠柏', '平凡', '亦玉', '孤兰', '秋珊', '新筠', '半芹', '夏瑶', '念文', '晓丝', '涵蕾', '雁凡', '谷兰', '灵凡', '凝云', '曼云', '丹彤', '南霜', '夜梦', '从筠', '雁芙', '语蝶', '依波', '晓旋', '念之', '盼芙', '曼安', '采珊', '初柳', '迎天', '曼安', '南珍', '妙芙', '语柳', '含莲', '晓筠', '夏山', '尔容', '念梦', '傲南', '问薇', '雨灵', '凝安', '冰海', '初珍', '宛菡', '冬卉', '盼晴', '冷荷', '寄翠', '幻梅', '如凡', '语梦', '易梦', '千柔', '向露', '梦玉', '傲霜', '依霜', '灵松', '诗桃', '书蝶', '冰蝶', '山槐', '以晴', '友易', '梦桃', '香菱', '孤云', '水蓉', '雅容', '飞烟', '雁荷', '代芙', '醉易', '夏烟', '依秋', '依波', '紫萱', '涵易', '忆之', '幻巧', '水风', '安寒', '白亦', '怜雪', '听南', '念蕾', '梦竹', '千凡', '寄琴', '采波', '元冬', '思菱', '平卉', '笑柳', '雪卉', '谷梦', '绿蝶', '飞荷', '平安', '孤晴', '芷荷', '曼冬', '尔槐', '以旋', '绿蕊', '初夏', '依丝', '怜南', '千山', '雨安', '水风', '寄柔', '幼枫', '凡桃', '新儿', '夏波', '雨琴', '静槐', '元槐', '映阳', '飞薇', '小凝', '映寒', '傲菡', '谷蕊', '笑槐', '飞兰', '笑卉', '迎荷', '元冬', '书竹', '半烟', '绮波', '小之', '觅露', '夜雪', '寒梦', '尔风', '白梅', '雨旋', '芷珊', '山彤', '尔柳', '沛柔', '灵萱', '沛凝', '白容', '乐蓉', '映安', '依云', '映冬', '凡雁', '梦秋', '醉柳', '梦凡', '若云', '元容', '怀蕾', '灵寒', '天薇', '白风', '访波', '亦凝', '易绿', '夜南', '曼凡', '亦巧', '青易。冰真', '白萱', '友安', '诗翠', '雪珍', '海之', '小蕊', '又琴', '香彤', '语梦', '惜蕊', '迎彤', '沛白', '雁山', '易蓉', '雪晴', '诗珊', '冰绿', '半梅', '笑容', '沛凝', '念瑶', '如冬', '向真', '从蓉', '亦云', '向雁', '尔蝶', '冬易', '丹亦', '夏山', '醉香', '盼夏', '孤菱', '安莲', '问凝', '冬萱', '晓山', '雁蓉', '梦蕊', '山菡', '南莲', '飞双', '凝丝', '思萱', '怀梦', '雨梅', '冷霜', '向松', '迎丝', '迎梅', '听双', '山蝶', '夜梅', '醉冬', '雨筠', '平文', '青文', '半蕾', '幼菱', '寻梅', '含之', '香之', '含蕊', '亦玉', '靖荷', '碧萱', '寒云', '向南', '书雁', '怀薇', '思菱', '忆文', '若山', '向秋', '凡白', '绮烟', '从蕾', '天曼', '又亦', '依琴', '曼彤', '沛槐', '又槐', '元绿', '安珊', '夏之', '易槐', '宛亦', '白翠', '丹云', '问寒', '易文', '傲易', '青旋', '思真', '妙之', '半双', '若翠', '初兰', '怀曼', '惜萍', '初之', '宛丝', '幻儿', '千风', '天蓉', '雅青', '寄文', '代天', '惜珊', '向薇', '冬灵', '惜芹', '凌青', '谷芹', '雁桃', '映雁', '书兰', '寄风', '访烟', '绮晴', '傲柔', '寄容', '以珊', '紫雪', '芷容', '书琴', '寻桃', '涵阳', '怀寒', '易云', '采蓝', '代秋', '惜梦', '尔烟', '谷槐', '怀莲', '涵菱', '水蓝', '访冬', '半兰', '又柔', '冬卉', '安双', '冰岚', '香薇', '语芹', '静珊', '幻露', '访天', '静柏', '凌丝', '小翠', '雁卉', '访文', '凌文', '芷云', '思柔', '巧凡', '慕山', '依云', '千柳', '从凝', '安梦', '香旋', '映天', '安柏', '平萱', '以筠', '忆曼', '新竹', '绮露', '觅儿', '碧蓉', '白竹', '飞兰', '曼雁', '雁露', '凝冬', '含灵', '初阳', '海秋', '冰双', '绿兰', '盼易', '思松', '梦山', '友灵', '绿竹', '灵安', '凌柏', '秋柔', '又蓝', '尔竹', '天蓝', '青枫', '问芙', '语海', '灵珊', '凝丹', '小蕾', '迎夏', '水之', '飞珍', '冰夏', '亦竹', '飞莲', '海白', '元蝶', '芷天', '怀绿', '尔容', '元芹', '若云', '寒烟', '听筠', '采梦', '凝莲', '元彤', '觅山', '代桃', '冷之', '盼秋', '秋寒', '慕蕊', '海亦', '初晴', '巧蕊', '听安', '芷雪', '以松', '梦槐', '寒梅', '香岚', '寄柔', '映冬', '孤容', '晓蕾', '安萱', '听枫', '夜绿', '雪莲', '从丹', '碧蓉', '绮琴', '雨文', '幼荷', '青柏', '初蓝', '忆安', '盼晴', '寻冬', '雪珊', '梦寒', '迎南', '如彤', '采枫', '若雁', '翠阳', '沛容', '幻翠', '山兰', '芷波', '雪瑶', '寄云', '慕卉', '冷松', '涵梅', '书白', '乐天', '雁卉', '宛秋', '傲旋', '新之', '凡儿', '夏真', '静枫', '乐双', '白玉', '问玉', '寄松', '丹蝶', '元瑶', '冰蝶', '访曼', '代灵', '芷烟', '白易', '尔阳', '怜烟', '平卉', '丹寒', '访梦', '绿凝', '冰菱', '语蕊', '思烟', '忆枫', '映菱', '凌兰', '曼岚', '若枫', '傲薇', '凡灵', '乐蕊', '秋灵', '谷槐', '觅云', '振海', '振国', '正德', '正浩', '伟博', '伟毅', '伟才', '伟诚', '伟茂', '伟懋', '伟祺', '伟彦', '伟晔', '荣轩', '锐泽', '锐真', '锐志', '锐智', '睿博', '睿才', '睿诚', '睿慈', '锐达', '锐锋', '锐翰', '锐进', '锐精', '锐立', '锐利', '锐思', '锐逸', '锐意', '齐骐', '齐骥', '天骐', '天骥', '乐山', '乐水', '立家', '立业', '保国', '卫国', '建功', '建业', '安道', '乐道', '卓群', '超群', '俊雄', '俊雅', '俊彦', '俊逸', '成仁', '成双', '成天', '成文', '成业', '成益', '嘉澍', '嘉熙', '嘉禧', '嘉祥', '嘉歆', '嘉许', '俊悟', '俊晤', '俊侠', '俊贤', '嘉年', '嘉平', '嘉庆', '嘉荣', '嘉容', '嘉瑞', '承福', '承基', '承教', '承平', '成化', '成济', '成礼', '成龙', '知国', '君宇', '泽城', '温谨', '风宇', '君冠', '文德', '棋苑', '轩峻', '知彰', '泽韶', '尚兴', '远辰 辉轩', '荣茂', '圣瀚', '世翰', '彬逸', '鸿颜', '泽雷', '宇哲', '展信', '晋茂', '远熙', '弘瑞', '弘霖 圣江', '棋泽', '弘德', '轩诚', '博羽', '晋刚', '晋城', '杰邦', '启明', '博恒', '泽胜', '昌裕', '杰玮 德鸿', '智旭', '哲城', '博浩', '依平', '泽拓', '泰耀', '德桦', '鸿灿', '伟耀', '浩善', '伯灿', '月硕 卓耀', '秀方', '鸿祺', '尚林', '建琛', '锐翔', '远志', '彬琪', '靖元', '森晖', '景宸', '朋宸', '淇方 峻浩', '祉鑫', '超耿', '灿轩', '柯昊', '志天', '文崇', '瑾方', '楠睿', '琪硕' ]; names.forEach(async (name) =&gt; &#123; try &#123; let reptileUrl = `https://www.goodstudydayup.com:1443/wnl/H5Test/nameresult?tid=$&#123;tid&#125;&amp;name=$&#123;name&#125;&amp;op=$&#123;op&#125;`; let r1 = await superagent.get(reptileUrl); let o1 = JSON.parse(r1.text); if (o1.data.title) &#123; //let flag = await db.Wnl.find(&#123; 'data.title': o1.data.title &#125;); //if ( flag.length === 0 ) &#123; o1.data.tid = tid; o1.data.op = op; o1.data.name = name; console.log(o1); db.Wnl.create(o1); //&#125; &#125; &#125; catch (e) &#123; &#125; &#125;); // &#125; &#125; &#125; catch (e) &#123; &#125; &#125;); &#125;); 运行完上面的代码，\b\b经过我的测试总计会拿到大概一万条左右的数据。\b然而这里面却又很多重复的数据。重复的数据会对我们\b\b分析来说没有价值。\b这里就要考虑如何清洗我们的数据。 所以\b这里先要对数据做持久化处理。 \b\b不然我们怎么清洗数据呢？ 持久化数据我们\b一般会选择\b写文件或存数据库。 \b\b这里根据我们的数据结构(json数据)我们选择MongoDB数据库。 接下来我们开始清洗\b数据\b去重12345678910111213141516171819202122232425262728if(false) &#123; console.log(&apos;数据去重&apos;); (async () =&gt; &#123; let data = await db.Wnl.aggregate([ &#123; $group: &#123; _id: &apos;$data.title&apos;, count: &#123; $sum: 1 &#125;, dups: &#123; $addToSet: &apos;$_id&apos; &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125; ]); data.forEach((it) =&gt; &#123; it.dups.shift(); db.Wnl.remove(&#123; _id: &#123; $in: it.dups &#125; &#125;); db.Wnl.deleteMany(&#123; _id: &#123; $in: it.dups &#125; &#125;, (err, res) =&gt; &#123; &#125;); &#125;); &#125;)();&#125; 去玩重结果只剩下几十条数据 \b\b\b数据归档1234567891011if(true) &#123; let tids = [9,10, 15, 16,21,22,23,24,25,26,27, 29]; tids.forEach(async (tid) =&gt; &#123; let data = await db.Wnl.find(&#123; &apos;data.tid&apos;: tid &#125;); util.writeData(data[0].data.tid, data); &#125;);&#125; 最终\b\b成功归档 12tid10.json tid16.json tid22.json tid24.json tid26.json tid29.jsontid15.json tid21.json tid23.json tid25.json tid27.json tid9.json 最后我们可以单纯的用拿到的数据，单纯的做点其他事了。 未完待续…","categories":[],"tags":[]},{"title":"mongodb query要点","slug":"mongodb-query要点","date":"2018-08-30T01:03:36.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/08/30/mongodb-query要点/","link":"","permalink":"https://ryansuen.github.io/2018/08/30/mongodb-query要点/","excerpt":"","text":"普通查询123456789101112131415&gt; db.customer.findOne()&#123; &quot;_id&quot; : ObjectId(&quot;57636c8e35defe029962107e&quot;), &quot;_class&quot; : &quot;com.bu2trip.ticket.model.Customer&quot;, &quot;name&quot; : &quot;wang&quot;, &quot;phone&quot; : &quot;18408221624&quot;, &quot;gender&quot; : 1, &quot;birthday&quot; : &quot;1995-7-9&quot;, &quot;passport&quot; : &quot;620524&quot;, &quot;login_user&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;5760e593086659036b77c124&quot;), &quot;email&quot; : &quot;test@bu2trip.com&quot;, &quot;phone&quot; : &quot;110&quot; &#125;&#125; 查询整个内嵌文档1db.customer.find(&#123;&quot;login_user&quot; : &#123;&quot;_id&quot;:ObjectId(&quot;5760e593086659036b77c124&quot;), &quot;email&quot; : &quot;test@bu2trip.com&quot;,&quot;phone&quot; : &quot;110&quot;&#125;&#125;) 只针对内嵌文档的特定键值进行查询如下：1db.customer.findOne(&#123;&quot;login_user.phone&quot;:&quot;110&quot;&#125;) ps: 嵌套查询并非直接传入嵌套对象，而是出入具体属性的应用路径。 mongodb中没有像mysql中直接去重的指令。如下是找到的去重方法的小小改良版。去重用处就很明显了可用于数据清洗。直接上实例 1234567891011121314151617181920212223242526(async () =&gt; &#123; let data = await db.Wnl.aggregate([ &#123; $group: &#123; _id: '$data.title', count: &#123; $sum: 1 &#125;, dups: &#123; $addToSet: '$_id' &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125; ]); data.forEach((it) =&gt; &#123; it.dups.shift(); db.Wnl.remove(&#123; _id: &#123; $in: it.dups &#125; &#125;); db.Wnl.deleteMany(&#123; _id: &#123; $in: it.dups &#125; &#125;, (err, res) =&gt; &#123; &#125;); &#125;);&#125;)(); 下面来解析： 使用aggregate聚合查询重复数据 $group中是查询条件，根据content、endTime、startTime字段来聚合相同的数据； $count用来统计重复出现的次数,$match来过滤没有重复的数据； $addToSet将聚合的数据id放入到dups数组中方便后面使用； 查询结果使用forEach进行迭代id来删除数据 shift()作用是剔除队列中第一条id，避免删掉所有的数据； PS:注意函数的大小写，mongoDB是严格区分大小写的！！！ 未完待续…","categories":[],"tags":[]},{"title":"mongodb设置使用密码才能连接","slug":"mongodb设置使用密码才能连接","date":"2018-08-28T00:42:03.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/08/28/mongodb设置使用密码才能连接/","link":"","permalink":"https://ryansuen.github.io/2018/08/28/mongodb设置使用密码才能连接/","excerpt":"","text":"mongodb密码和传统数据如mysql等有些区别： mongodb的用户名和密码是基于特定数据库的，而不是基于整个系统的。所有所有数据库db都需要设置密码mongodb要先设置管理用户和密码： mongod开启服务， mongo连接服务。 &gt; show dbs use admin 创建管理员账户 12//这里的db是admindb.createUser(&#123;user:&apos;admin&apos;,pwd:&apos;yourpassword&apos;,roles:[&#123;role:&apos;root&apos;,db:&apos;admin&apos;&#125;], mechanisms:[&quot;SCRAM-SHA-1&quot;]&#125;) 验证第3步用户添加是否成功 123db.auth(\"admin\", \"yourpassword\") 如果返回1，则表示成功。exit退出系统//db.auth()方法理解为 用户的验证功能 开启mongodb密码验证。 12345678910111213141516//新建mongdb配置文件sudo vi /usr/local/mongodb/mongodb.conf//添加配置#端口号port = 27017#数据目录dbpath = /data/db#日志目录logpath = /data/logs/mongodb.log#设置后台运行#fork = true#日志输出方式logappend = true#开启密码认证auth = true 重启mongodb 1mongod --config /usr/local/mongodb/mongodb.conf mongo重新连接服务，用第3步的 管理员账户登录，然后才能用该账户创建其他数据库管理员账号 12use admindb.auth(&quot;admin&quot;, &quot;yourpassword&quot;) 登录管理员账户后，再新建你需要管理的mongodb 数据库的账号密码。 1234567use spider //yourdatabase//dbOwner 代表数据库所有者角色，拥有最高该数据库最高权限。比如新建索引等db.createUser(&#123; user: &quot;ryan&quot;, pwd: &quot;yourpassword&quot;, roles: [&#123; role: &quot;dbOwner&quot;, db: &quot;spider&quot; &#125;], mechanisms:[&quot;SCRAM-SHA-1&quot;]&#125;)//readWrite 该用户只拥有读写权限。db.createUser(&#123; user: &quot;ryansuen&quot;, pwd: &quot;yourpassword&quot;, roles: [&#123; role: &quot;readWrite&quot;, db: &quot;spider&quot; &#125;], mechanisms:[&quot;SCRAM-SHA-1&quot;]&#125;) 现在数据库的用户名和密码就建好了。可以使用：mongodb://youruser2:yourpassword2@localhost/yourdatabase来链接","categories":[],"tags":[]},{"title":"设计模式命令模式","slug":"设计模式命令模式","date":"2018-07-21T00:12:50.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/07/21/设计模式命令模式/","link":"","permalink":"https://ryansuen.github.io/2018/07/21/设计模式命令模式/","excerpt":"","text":"命令模式比喻定义 某位客人点餐或着打电话定餐后,服务员把他的需求定在订清单上，然后交给后厨，客人不用关心是哪个厨师帮他炒菜。客人可以要求延迟炒菜，或取消订单，只要订单在厨师便不会忘记。点餐人过多，厨师还可以按单餐的顺序炒菜. 记录订餐信息的清单，便是命令模式中的命令对象 命令模式中的指令指的是一个执行某些特定事情的指令 常见应用场景 有时候需求向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。希望用一种松耦合的方式来设计 程序 ，使得请求发者和请求接收者能够消除彼此之间的耦合关系。 Javascript中的命令模式12345678910111213141516171819202122var bindClick = function( button, func ) &#123; button.addEventListener('click', func, false);&#125;;var MenuBar = &#123; refresh: function() &#123; console.log('refresh menu!'); &#125;&#125;;var SubMenu = &#123; add: function() &#123; console.log('add sub menu!'); &#125;, del: function() &#123; console.log('del sub menu!'); &#125;&#125;;bindClick( button1, MenuBar.refresh );bindClick( button2, SubMenu.add );bindClick( button3, SubMenu.del ); upgrade1234567891011121314151617181920212223242526272829303132var setCommand = function( button, func ) &#123; button.addEventListener('click', func, false);&#125;;var MenuBar = &#123; refresh: function() &#123; console.log('refresh menu!'); &#125;;&#125;;var RefreshMenuBarCommand = function( receiver ) &#123; return function() &#123; receiver.refresh(); &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommnad( MenuBar );setCommand( button1, refreshMenuBarCommand );// upgrade morevar RefreshMenuBarCommand = function( receiver ) &#123; return &#123; execute: function() &#123; receiver.refresh(); &#125; &#125;;&#125;;var setCommand = function( button, command ) &#123; button.addEventListener( 'click', function() &#123; command.execute(); &#125;, false );&#125;; 撤销命令123456789101112131415161718192021222324252627282930var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');var cancleBtn = docuemnt.getElementById('cancleBtn');var MoveCommand = function( receiver, pos ) &#123; this.reciver = receiver; this.pos = pos; this.oldPos = null;&#125;;MoveCommnad.prototype.execute = function() &#123; this.receiver.start(‘left’, this.pos, 1000, 'strongEaseOut'); this.oldPos = this.receiver.dom.getBoundingClientRect()[this.receiver.propertyName];&#125;;MoveCommand.prototype.undo = function() &#123; this.receiver.start('left', this.oldPos, 1000, 'strongEaseOut');&#125;var moveCommand;moveBtn.addEventListener('click', function() &#123; var animae = new Animate('ball'); moveCommand = new MoveCommand( animate, pos.value); moveCommand.execute();&#125;, false);cancleBtn.addEventListener('click', function()&#123; moveCommand.undo();&#125;， false); 撤销和重做12345678910111213141516171819202122232425262728293031323334353637383940414243var Ryu = &#123; attack: function() &#123; console.log('攻击'); &#125;, defense: function() &#123; console.log('防御'); &#125;, jump: function() &#123; console.log('跳跃'); &#125;, crouch: function() &#123; console.log('蹲下'); &#125;&#125;;var makeCommand = function( receiver, state ) &#123; return function() &#123; receiver[state](); &#125;&#125;;var commands = &#123; '119': 'jump', '115': 'crouch', '97': 'defense', '100': 'attack'&#125;;var commandStack = [];document.addEventListener('keypress', function(ev) &#123; var keyCode = ev.keyCode, command = makeCommand( Ryu, commands[ keyCode ] ); if(command) &#123; command(); commandStack.push( command ); &#125; document.getElementById('replay').addEventListener('click', function() &#123; var command; while(command = commandStack.shift()) &#123; command(); &#125; &#125;, false);&#125;, false); 宏命令12345678910111213141516171819202122232425262728293031323334353637var closeDoorCommand = &#123; execute: function() &#123; console.log('colse door!'); &#125;;&#125;;var openPcCommand = &#123; execute: function() &#123; console.log('open pc!'); &#125;;&#125;;var openQQCommand = &#123; execute: function() &#123; console.log('login QQ!'); &#125;&#125;;var MacroCommand = function() &#123; return &#123; commandList: [], add: function(command) &#123; this.commandList.push(command); &#125;, execute: function() &#123; this.commandList.forEach(function(command)&#123; command.execute(); &#125;); &#125; &#125;;&#125;;var macroCommand = MacroCommand();macroCommand.add( colseDoorCommand );macroCommand.add( openPcCommand );macroCommand.add( openQqCommand );macroCommand.execute(); 智能命令与傻瓜命令closeDoorCommand中没有包含任何recevier，包含recevier的叫傻瓜命令，能更好的解藕；不包含的叫智能命令。 拓展：对比一下，函数的传参与不传参。拓展：什么东西叫纯函数？","categories":[],"tags":[]},{"title":"前端学习nginx之理解nginx配置","slug":"前端学习nginx之理解nginx配置","date":"2018-06-17T07:00:31.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/06/17/前端学习nginx之理解nginx配置/","link":"","permalink":"https://ryansuen.github.io/2018/06/17/前端学习nginx之理解nginx配置/","excerpt":"","text":"先看看nginx.conf.default这个文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*; location块配置理解location 语法结构 123location [ = | ~ | ~* | ~^ ] uri &#123; ...&#125; 其中uri是待\b匹配的请求字符串，也就是待匹配的请求。可以是不\b含正则表达的字符串，如/index.html（\b“标准uri”）。 也可以是正则表达式，如.php$ \b匹配以点php\b结尾的\b请求。 中括号的内容可选，当没有中括号的内容。nginx 首先在server的多个location块中搜索是否有标准\buri与请求字符串相\b匹配的，如果有多个可以\b匹配，就记录匹配度最高的一个，注意这里只是先记录下来。然后服务器再用location中的正则uri与\b请求字符串匹配，当第一个uri\b匹配成功，结束搜索，并用这个location块处理请求，如果正则全部匹配失败\b，则使用刚才那个记录匹配度最的location块处理请求。 可先参数的含义 = 表示请求字符串要与uri严格匹配。 ~ 表示uri包含正则表达式，并且区分大小写。（实际验证未区分大小写） ~* 表示uri包含正则表达式，并且不区分大小写。 ^~ 用于\b标准uri前，要求nginx找到标识uri和请求字符串匹配度最高的location后，立即使用\b此location处理请求，而不再使用location中的正则uri和\b请求字\b符串\b\b\b匹配。 \b配置请求的根目录123location /data/ &#123; root path_to_root;&#125; 更改location的uri123location ~ ^/data/(.+\\.(htm|html))$ &#123; alias /locationtest1/other/$1;&#125; 设置网\b站的错误页面\b语法：error_page code [=[response]] uri 123456error_page 404 /404.html;error_page 403 http://site.com/forbidden.html;error_page 410 =310 /empty.gif;location /404.html &#123; root /server/errorpage/;&#125; 基于ip的访问权限设置12345location / &#123; deny 192.168.1.1; #不支持写多个ip，要\b支持多个重复使用deny allow 192.168.1.0/24; deny all;&#125; 这里会参生疑问，我们先禁止了192.168.1.1访问，然后又允\b许了192.168.1.0/24访问。最后又禁止所有访问。哪到底192.168.1.0/24能不能访问? 如果遇到匹配的配置，则停止向下搜索。 nginx gzip1gzip on; 默认值为off,即不启用gzip;只有gzip为on是gzip相关的\b指令才有效。 1gzip_buffers number size; number nginx向系统申请缓存空间的个数 size 第个缓存空间的大小。 nginx在对响应输出的数据进行gzip压缩时需要向系统申请number * size 大小的空间用于\b存储数据。size的值为系统内存页 一页的大小，一般为4k或8k; 1gzip_comp_level level; 该指令用于设定gzip的压缩程度，压缩程度从底到高\b分1~9个等级。1\b\b压缩程度最低，压缩效率最高。9压缩程度最高，压缩效率最低，最耗时。 12gzip_disable regex ...;gzip_disable MSIE [4-6]\\. 对哪些UA不作gzip处理。 12gzip_min_length length;gzip_min_length 1024; \b响应\b超过多少才gzip压缩。如果太小，压缩后可能会变大。建议最小1024，即1kb; 123456gzip on;gzip_min_length 1024;gzip_buffers 4 16k;gzip_comp_level 2;gzip_types text/plain application/z-javascript text/css application/xml;... rewriteRewrite的Flags last – 完成重写指令后，搜索相应的URI和位置。相当于Apache里的[L]标记，表示完成rewrite，不再匹配后面的规则。 break – 中止Rewirte，不在继续匹配。 redirect – 返回临时重定向的HTTP状态302。 permanent – 返回永久重定向的HTTP状态301。 文件及目录匹配 -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 正则表达式全部符号解释 ~ 为区分大小写匹配 ~* 为不区分大小写匹配 !~和!~* 分别为区分大小写不匹配及不区分大小写不匹配 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘/(’ 或 ‘/)’。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 域名跳转12345678#例1...server &#123; listen 80; server_name jump.myweb.name; rewrite ^/ http://www.myweb.info/; #域名跳转&#125;... 多域名跳转12345678server &#123; listen 80; server_name jump.myweb.name jump.myweb.info; if ($host myweb\\.info) #注意正则表达式中对点号“.”要用“\\”进行转义 &#123; rewrite ^(.*) http://jump.myweb.name$1 pe rmanent; #多域名跳转 &#125;&#125; 三级域名跳转123456789server &#123; listen 80; server_name jump1.myweb.name jump2.myweb.name; if ($http_ host ~* ^(.*) \\.myweb.name$) &#123; rewrite (.*) http://jump.myweb.name$1; break; &#125;&#125; 代理123456789101112server &#123; #监听80端口 listen 80; server_name localhost; # individual nginx logs for this web vhost access_log /tmp/access.log; error_log /tmp/error.log ; location / &#123; proxy_pass http://www.baidu.com; &#125;&#125; 负载均衡负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 简单说来就是：将负载进行平衡。人话就是将请求分派给其它服务器以及如何分派。 \b\b\b默认的规则1234567891011# 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。#要放在http下。 upstream mt &#123; server mt1.com; # 应用服务器1 server mt2.com; # 应用服务器2&#125; #放在server下location /api &#123; proxy_pass http://mt;&#125; 权重策略12345678upstream mt &#123; server 127.0.0.1:8085 weight=1; # 应用服务器1 server 127.0.0.1:8086 weight=9; # 应用服务器2&#125;location /api &#123; proxy_pass http://mt;&#125; ip_hash策略12345678910111213#3、IP绑定 ip_hash#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，#可以解决session的问题;在不考虑引入分布式session的情况下，#原生HttpSession只对当前servlet容器的上下文环境有效upstream mt &#123; ip_hash; server mt1.com:8085; # 应用服务器1 server mt2.com:8086; # 应用服务器2&#125;location /api &#123; proxy_pass http://mt;&#125;","categories":[],"tags":[]},{"title":"前端学习nginx二","slug":"前端学习nginx二","date":"2018-05-26T14:36:31.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/05/26/前端学习nginx二/","link":"","permalink":"https://ryansuen.github.io/2018/05/26/前端学习nginx二/","excerpt":"","text":"这一期我们来分享几个nginx容易遇到的问题： nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)1234567ryan:~ ryan$ sudo nginx //启动nginxnginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use)nginx: [emerg] still could not bind() 错误提醒的多明显。”bind() to 0.0.0.0:80 failed “。 我们可以很容易猜到大概意思就是不能使用80端口。 再猜一下，80端口可能被占用了。 我们先验证下80端口有没有被占用。 如果被占用关闭之前的进程，再启动一次nginx. mac 查看端口是否被占用。1234// 查80端口是被什么进程占用lsof -i tcp:80kill -9 pid window 查看端口是否被占用。12//cmd下运行如下命令netstat –ano Proto Local Address Foreign Address State PID TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 656 上面找到了占用80的pid,然后 1C:\\&gt;Taskkill /PID 656 /F 当然也可以能过运行1C:\\&gt;tasklist //找到656这个进程所对应的程序名。然后直接通过任务管理器关闭相应的进程就行了。 ps有时候我们可能已经开启了nginx服务。再次开启nginx服务，毫无疑问会报上面的错误。如果是在生产环境，就不要中断服务了。可以如下操作 1sudo nginx -s reload 如果确实想重启nginx。可以如下操作： 12sudo nginx -s stopsudo nginx 当我们重新配置一个新的nginx服务访问时出现”403 Forbidden“解决方法当我们在访问 http://localhost 时屏幕显示”403 Forbiddennginx/1.12.0”。 当然里的前端我们先配置了80端口下的这个服务。现在我们先来猜问题： 403 forbidden =&gt; 懂点英文的都会知道。被禁止了。 我们再顺着被禁止了去猜。假如我们被禁止进入某一场所，说明我们是没有权限。 大概猜到是权限问题。大致会出现两种权限的可能： 我们没有权限访问服务器。我们的服务器没有权限访问网站所对应的文件。 再稍稍猜一下。自已配置的服务器怎么会不让自己访问。我们就可以排除第一种可能啦。我们先假设可能是服务器不能访问网站所对应的文件去试试。 修改文件访问权限1shell&gt;chmod-R 755 /usr/local/nginx/html 重启了下nginx服务器好像真的可以访问。验证了我们的猜想。我自己遇到过一次改了权限，仍不能访问的情况。最终发现是文件组受了限制。 12345//不可访问路径drwxrwxrwx 4 ryan（用户/属主） staff(属组) 136 9 26 00:12 nginx//可访问路径drwxr-xr-x 2 ryan admin 68 9 26 00:11 www 12//改变所属的组chown -R ryan:admin /Users/ryan/Documents/www/nginx/test/ 拓展按如上的方式修改文件所属的组，细想不是很合理，上面只是说了是权限问题,没有说得足够细，以及为什么要将staff组改成admin组。这里继续补充。 liunx下的用户和用户组linux是多用户和多任务的系统，很可能存在多人同时使用一台liunx主机工作的情况。为了考虑每个人的隐私权，以及每个人的喜欢的工作环境。因此设计了“用户和用户组”这样的“文件所有者”。正因为此所以某一用户在访问其他用户的文件时为存在权限问题。 上面所讲的内容如何和我们遇到的nginx的问题关联起来。 12345678910111213141516//linux 命令行下执行ps aux | grep nginxnobody 64601 0.0 0.0 4304288 1224 ?? S 3:07下午 0:00.00 nginx: worker processroot 64600 0.0 0.0 4301984 580 ?? Ss 3:07下午 0:00.00 nginx: master process nginx// 我们可以看到nginx 的工作进程的用户是nobody，即nobody这个用户运行的nginx的工作进程。 root这个用户运行的nginx的主进程。//这里就要发问了，为什么主进程是root用户的，工作进程是nobody这个用户的？//主进程归root用户是因为启动nginx的时候使用的是&quot;sudo nginx&quot;,明白了吧！工作进程归nobody是因为在nginx.conf配置当中我们设置的user是nobody(user设置运行nginx的用户); user user [group]; //这个时候我们去查看网站根目录所属的用户及用户组ls -ldrwxr-xr-x 6 ryan staff 192 6 2 00:56 website.root//我们可以看到用户是ryan 用户组是staff.//到这里很清楚了吧。 一个nobody的用户想要去访问ryan的文件。你死不死当然没有权限啦！//悟性高的可能已经知道要怎么改了。这里我们先不说怎么改，引了别一个问题。眼尖的同学可能会问了， staff是什么用户组？ Linux 中的 wheel 组和 staff 组 及admin组区别。 The wheel group is used to control those people that can su to the root user (though this is made irrelevant by the sudo command). All of the users on your system will be in the staff group, so by changing group ownership of files to staff the group permissions will apply to all users. All of the administrators on your system will be in the wheel group, so by changing group ownership of the files to wheel group permissions will apply to all of the administrators, global permissions will apply to any other users. My advice is that, except for files that you have created, you leave the group ownership and permissions alone. Unix is very particular about file ownership and permissions in certain areas and changing them only leads to trouble. 所有的用户都属于 staff 组， 只有具有管理员性质的用户位于 wheel 组中。 wheel 是一个特殊的用户组，该组的用户可以使用 su 切换到 root，而 staff 组是所有普通用户的集合。 admin组就不用说了，翻译过来就知道了管理员组。 讲到这里可能不用说如何修改上述403的问题都知道如何修改了。 把nginx的启动用户改成root； 123456user root staff;//我试着直接设置，重载nginx的时候报错了。看来限制了root用户必须要带上组。user root;//设置user nobody,并没有报错，说明对nobody并没有此限制，我猜想原因是有nobody用户，也有nobody组，而有root用户而没有root组。 有兴趣的可以去了解一下”/etc/group和/etc/passwd及/etc/shadow文件”主个文件的内容。 今天的分享先到这里了。","categories":[],"tags":[]},{"title":"前端学习nginx一","slug":"前端学习nginx一","date":"2018-05-26T12:36:29.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/05/26/前端学习nginx一/","link":"","permalink":"https://ryansuen.github.io/2018/05/26/前端学习nginx一/","excerpt":"","text":"简述Nginx是一款轻量级的HTTP服务器（相比于Apache、Lighttpd等），同时是一个高性能的HTTP和反向代理服务器。Nginx主要以事件驱动的方式编写，这让它拥有非常好的性能，同时也能非常高效的实现反向代理和负载均衡。 nginx的几项基本特征： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲 无缓存的反向代理加速，简单的负载均衡和容错 FastCGI，简单的负载均衡和容错 模块化的结构，包括gzipping,byte ranges,chunked responses,以及SSI-filter等filter。 支持SSL和TLSSNI. 安装nginxwindow安装 安装步骤省略，闲麻烦可以安装一个集成环境–phpStudy。 不是嫌弃windows电脑，极想买一台性能很6的window电脑，实在囊中羞涩。 Mac安装1brew update &amp;&amp; brew install nginx 安装完成后可以用浏览器打开http://localhost:8080看到Nginx的欢迎信息。 一般情况下mac下nginx的 12345//安装路径如下：(可执行程序)/usr/local/Cellar/nginx/1.12.0_1/bin/nginx//配置所在路径/usr/local/etc/nginx/nginx.conf 先看看nginx的默认配置，后面再细讲123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 开启，停止，重新启动要启动nginx，可以直接运行nginx的可执行文件。也就是刚才说的“/usr/local/Cellar/nginx/1.12.0_1/bin/nginx”这个文件。一但nginx已经开启。可以带上“-s [参数]“执行nginx的可执行文件。如下： 1234567891011nginx -s signal``` signal 如下当中的一种：- stop 快速关闭- quit 优雅的关闭- reload 重新加载配置文件- reopen 重新打开日志文件。看到如上的信号，有小伙伴肯定会问stop 和 quit 都是关闭这两者有什么区别。 nginx -s quit //This command should be executed under the same user that started nginx. 官网原话，好懂吧！12 nginx -s reload123456789重启命令就更厉害了。先看一段官网原话：Once the master process receives the signal to reload configuration, it checks the syntax validity of the new configuration file and tries to apply the configuration provided in it. If this is a success, the master process starts new worker processes and sends messages to old worker processes, requesting them to shut down. Otherwise, the master process rolls back the changes and continues to work with the old configuration. Old worker processes, receiving a command to shut down, stop accepting new connections and continue to service current requests until all such requests are serviced. After that, the old worker processes exit.我们来大概翻译下：一但nginx主进程接收到reload的信号，会先去验证新配置的语法是否正确。如果成功也就是语法正确，nginx的主进程会开一个新的进程，发信息给旧的主进程请求关闭。如不reload不成功，主进程会继续使用旧的主进程，使用旧的配置。 旧的主进程接上到关闭命令会停止接收新的链接并继续服务已接收的链接直到服务完成。这之后才会关闭。我们用人话来说翻译下上面的内容： nginx能够不中断服务启用新的配置，不知道大家如何看，反正我觉得很吊。#### 其它优雅的结束方式: kill -s QUIT NGINX-PID1234主进程的PID（process id）一般会被写入nginx.pid。 这个文件一般在”/usr/local/nginx/logs 或 /var/run“下。通过如上的方式如果找不到nginx的进程id可以执行如下命令找到。 ps -ax | grep nginx12### 配置语法检查命令 nginx -t` 好啦！今天的分享就先到这里了,下期再见。","categories":[],"tags":[]},{"title":"在Mac上使用ssh-key免密码登录服务器","slug":"在Mac上使用ssh-key免密码登录服务器","date":"2018-04-20T14:26:57.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/04/20/在Mac上使用ssh-key免密码登录服务器/","link":"","permalink":"https://ryansuen.github.io/2018/04/20/在Mac上使用ssh-key免密码登录服务器/","excerpt":"","text":"通常来说，我们使用 ssh user@host -p port，再输入密码，才能 ssh 到服务器进行管理。人类与动物的区别在于人会使用工具。所以我们要利用一些工具来简化我们的操作。 好在 Unix 系的操作系统提供了各种 ssh 支持。我们得以实现偷懒的目的。 先假设我们有一台服务器，主机名 testhost，ip 为 8.8.8.8，账号为 foo，密码为 bar，ssh 端口为 2222。一般的连接方式是： 12$ ssh foo@8.8.8.8 -p 2222password: bar 不仅很麻烦，还要记忆 IP 和端口，当我们有很多台服务器的时候，一定会疯掉！现在，我们来简化操作。 一、普通方式：~/.bash_profileAlias 相当于一种快捷方式或别名，让我们能把一长串命令简化成一个简短的命令。比如 Mac OSX 下没有直接的 ‘ll’ 命令，可以用 ‘ls -alF’ 实现 ‘ll’ 命令的效果。Alias 可以在主目录的 .bash_profile 文件中配置，此文件为隐藏文件，需要 ‘ls -alF’ 才能看到，如果 ‘ls -alF’ 还是看不到，可以自行创建此文件。在这个文件中，我们添加以下内容： 1alias testhost=&apos;ssh foo@8.8.8.8 -p 2222&apos; 保存后，就可以像这样登录服务器了： 12$ testhostpassword: bar 二、初级偷懒方式：~/.ssh/config在第一种方式中，实际我们没有利用到 ssh 的功能，只是利用了 bash 来简化，不太优雅。ssh 的问题应该由 ssh 来解决。所以，我们有了第二种方式。 ssh 有自己的配置文件，位置在 ~/.ssh/config 中，可以使用以下命令来编辑： 1$ vi ~/.ssh/config ssh 配置文件可以将服务器地址，端口，用户配置成一个别名。我们的范例服务器可配置为为： 1234Host testhost HostName 8.8.8.8 Port 2222 User foo 保存后，可以使用以下方式登录服务器： 12$ ssh testhostpassword: bar 三、高级偷懒方式：SSH Key在上面的两种方式中，我们都需要手工输入密码。能减掉这个步骤吗？当然可以！ssh 除了密码登录，还有更简单且更安全的登录方式，那就是 ssh key 登录。 先生成公钥和私钥，在 Mac OSX 终端（或 iTerm 2 等）中进入 ~/.ssh 目录，输入： 1$ ssh-keygen -t rsa 会询问一些问题，直接全部回车，即可在 ~/.ssh 目录中生成 id_rsa（私钥） 和 id_rsa.pub（公钥）文件。我们需要将公钥上传到 testhost 服务器的 ~/.ssh 目录下面，因为第二种方式中我们已经配置了 testhost 服务器，scp 也能识别这个服务器，所以，可以使用如下命令将文件传输到 testhost 服务器中： 1$ scp ~/.ssh/id_rsa.pub testhost:~/.ssh/ 接下来，用第二种方式登录到 testhost 服务器中，在 ~/.ssh 目录中使用以下命令将 id_rsa.pub 更名为 authorized_keys： 1foo@testhost: $ mv id_rsa.pub authorized_keys 最后确保下文件权限正常： 12foo@testhost: $ chmod 700 ~/.ssh/foo@testhost: $ chmod 600 ~/.ssh/authorized_keys 现在，我们可以在 Mac OSX 的终端中使用 ssh testhost 登录到 testhost 服务器了，无需输入密码，更无需记忆服务器参数。 如果无法连接，请在服务器的 /etc/ssh/sshd_config 文件中查看 PubkeyAuthentication 的值是否为 yes，如果不是，请修改为 yes ，并使用以下命令重启 ssh 服务： 12345foo@testhost: $ /etc/init.d/ssh restart//or sudo service sshd restart 可以用这个 ssh服务是用yum来安装的 都可以统一用service命令来控制 如果需要禁止密码登录，同样可以编辑 /etc/ssh/sshd_config 文件中 PasswordAuthentication 的值为 no 并重启 ssh 服务。 当有多Mac(设备)要登录同一台服务器时的解决方案： 先把新mac(设备)的id__rsa.pub都scp到目标服务器上，文件名后面统一加一个后缀, 如：id_rsa.pub.host1 再执行1cat id_rsa.pub.hostX &gt;&gt; .ssh/authorized_keys 每个文件执行一回,hostX要改成相应的文件名后缀。 将新的key 追加到authorized_keys当中。再把生成的authorized_keys给各主机SCP过去，就完事了。","categories":[],"tags":[]},{"title":"node.js fs","slug":"node-js-fs","date":"2018-03-12T13:52:47.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/03/12/node-js-fs/","link":"","permalink":"https://ryansuen.github.io/2018/03/12/node-js-fs/","excerpt":"","text":"fs api(阮老师的api文档)fs是filesystem的缩写，该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。但是，这个模块几乎对所有操作提供异步和同步两种操作方式，供开发者选择。 fs模块是唯一一个同时提供同步和异步API的模块。 readFile()，readFileSync()readFile方法用于异步读取数据。 1234fs.readFile(&apos;./image.png&apos;, function (err, buffer) &#123; if (err) throw err; process(buffer);&#125;); readFile方法的第一个参数是文件的路径，可以是绝对路径，也可以是相对路径。注意，如果是相对路径，是相对于当前进程所在的路径（process.cwd()），而不是相对于当前脚本所在的路径。 readFile方法的第二个参数是读取完成后的回调函数。该函数的第一个参数是发生错误时的错误对象，第二个参数是代表文件内容的Buffer实例。 readFileSync方法用于同步读取文件，返回一个字符串。 123456var text = fs.readFileSync(fileName, &apos;utf8&apos;);// 将文件按行拆成数组text.split(/\\r?\\n/).forEach(function (line) &#123; // ...&#125;); readFileSync方法的第一个参数是文件路径，第二个参数可以是一个表示配置的对象，也可以是一个表示文本文件编码的字符串。默认的配置对象是{ encoding: null, flag: ‘r’ }，即文件编码默认为null，读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回一个Buffer实例，否则返回的是一个字符串。 不同系统的行结尾字符不同，可以用下面的方法判断。 1234567// 方法一，查询现有的行结尾字符var EOL = fileContents.indexOf(&apos;\\r\\n&apos;) &gt;= 0 ? &apos;\\r\\n&apos; : &apos;\\n&apos;;// 方法二，根据当前系统处理var EOL = (process.platform === &apos;win32&apos; ? &apos;\\r\\n&apos; : &apos;\\n&apos;); writeFile()，writeFileSync()writeFile方法用于异步写入文件。 1234fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node.js&apos;, (err) =&gt; &#123; if (err) throw err; console.log(&apos;It\\&apos;s saved!&apos;);&#125;); 上面代码中，writeFile方法的第一个参数是写入的文件名，第二个参数是写入的字符串，第三个参数是回调函数。 回调函数前面，还可以再加一个参数，表示写入字符串的编码（默认是utf8）。 1fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node.js&apos;, &apos;utf8&apos;, callback); writeFileSync方法用于同步写入文件。 1fs.writeFileSync(fileName, str, &apos;utf8&apos;); 它的第一个参数是文件路径，第二个参数是写入文件的字符串，第三个参数是文件编码，默认为utf8。 exists(path, callback)exists方法用来判断给定路径是否存在，然后不管结果如何，都会调用回调函数。 123fs.exists(&apos;/path/to/file&apos;, function (exists) &#123; util.debug(exists ? &quot;it&apos;s there&quot; : &quot;no file!&quot;);&#125;); 上面代码表明，回调函数的参数是一个表示文件是否存在的布尔值。 需要注意的是，不要在open方法之前调用exists方法，open方法本身就能检查文件是否存在。 下面的例子是如果给定目录存在，就删除它。 1234if (fs.existsSync(outputFolder)) &#123; console.log(&apos;Removing &apos; + outputFolder); fs.rmdirSync(outputFolder);&#125; mkdir()，writeFile()，readFile()mkdir方法用于新建目录。 12345var fs = require(&apos;fs&apos;);fs.mkdir(&apos;./helloDir&apos;,0777, function (err) &#123; if (err) throw err;&#125;); mkdir接受三个参数，第一个是目录名，第二个是权限值，第三个是回调函数。 writeFile方法用于写入文件。 123456var fs = require(&apos;fs&apos;);fs.writeFile(&apos;./helloDir/message.txt&apos;, &apos;Hello Node&apos;, function (err) &#123; if (err) throw err; console.log(&apos;文件写入成功&apos;);&#125;); readFile方法用于读取文件内容。 123456var fs = require(&apos;fs&apos;);fs.readFile(&apos;./helloDir/message.txt&apos;,&apos;UTF-8&apos; ,function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码使用readFile方法读取文件。readFile方法的第一个参数是文件名，第二个参数是文件编码，第三个参数是回调函数。可用的文件编码包括“ascii”、“utf8”和“base64”。如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法，将其转为字符串。 12345var fs = require(&apos;fs&apos;);fs.readFile(&apos;example_log.txt&apos;, function (err, logData) &#123; if (err) throw err; var text = logData.toString();&#125;); readFile方法是异步操作，所以必须小心，不要同时发起多个readFile请求。 12345for(var i = 1; i &lt;= 1000; i++) &#123; fs.readFile(&apos;./&apos;+i+&apos;.txt&apos;, function() &#123; // do something with the file &#125;);&#125; 上面代码会同时发起1000个readFile异步请求，很快就会耗尽系统资源。 mkdirSync()，writeFileSync()，readFileSync()这三个方法是建立目录、写入文件、读取文件的同步版本。 12345fs.mkdirSync(&apos;./helloDirSync&apos;,0777);fs.writeFileSync(&apos;./helloDirSync/message.txt&apos;, &apos;Hello Node&apos;);var data = fs.readFileSync(&apos;./helloDirSync/message.txt&apos;,&apos;UTF-8&apos;);console.log(&apos;file created with contents:&apos;);console.log(data); 对于流量较大的服务器，最好还是采用异步操作，因为同步操作时，只有前一个操作结束，才会开始后一个操作，如果某个操作特别耗时（常常发生在读写数据时），会导致整个程序停顿。 readdir()，readdirSync()readdir方法用于读取目录，返回一个所包含的文件和子目录的数组。 123456789101112131415161718fs.readdir(process.cwd(), function (err, files) &#123; if (err) &#123; console.log(err); return; &#125; var count = files.length; var results = &#123;&#125;; files.forEach(function (filename) &#123; fs.readFile(filename, function (data) &#123; results[filename] = data; count--; if (count &lt;= 0) &#123; // 对所有文件进行处理 &#125; &#125;); &#125;);&#125;); readdirSync方法是readdir方法的同步版本。下面是同步列出目录内容的代码。 12345678910var files = fs.readdirSync(dir);files.forEach(function (filename) &#123; var fullname = path.join(dir,filename); var stats = fs.statSync(fullname); if (stats.isDirectory()) filename += &apos;/&apos;; process.stdout.write(filename + &apos;\\t&apos; + stats.size + &apos;\\t&apos; + stats.mtime + &apos;\\n&apos; );&#125;); stat()stat方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。我们往往通过该方法，判断正在处理的到底是一个文件，还是一个目录。 12345678910111213141516171819var fs = require(&apos;fs&apos;);fs.readdir(&apos;/etc/&apos;, function (err, files) &#123; if (err) throw err; files.forEach( function (file) &#123; fs.stat(&apos;/etc/&apos; + file, function (err, stats) &#123; if (err) throw err; if (stats.isFile()) &#123; console.log(&quot;%s is file&quot;, file); &#125; else if (stats.isDirectory ()) &#123; console.log(&quot;%s is a directory&quot;, file); &#125; console.log(&apos;stats: %s&apos;,JSON.stringify(stats)); &#125;); &#125;);&#125;); watchfile()，unwatchfile()watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 123456789101112var fs = require(&apos;fs&apos;);fs.watchFile(&apos;./testFile.txt&apos;, function (curr, prev) &#123; console.log(&apos;the current mtime is: &apos; + curr.mtime); console.log(&apos;the previous mtime was: &apos; + prev.mtime);&#125;);fs.writeFile(&apos;./testFile.txt&apos;, &quot;changed&quot;, function (err) &#123; if (err) throw err; console.log(&quot;file write complete&quot;); &#125;); unwatchfile方法用于解除对文件的监听。 createReadStream()createReadStream方法往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。 1234567891011121314151617181920212223242526272829303132var fs = require(&apos;fs&apos;);function readLines(input, func) &#123; var remaining = &apos;&apos;; input.on(&apos;data&apos;, function(data) &#123; remaining += data; var index = remaining.indexOf(&apos;\\n&apos;); var last = 0; while (index &gt; -1) &#123; var line = remaining.substring(last, index); last = index + 1; func(line); index = remaining.indexOf(&apos;\\n&apos;, last); &#125; remaining = remaining.substring(last); &#125;); input.on(&apos;end&apos;, function() &#123; if (remaining.length &gt; 0) &#123; func(remaining); &#125; &#125;);&#125;function func(data) &#123; console.log(&apos;Line: &apos; + data);&#125;var input = fs.createReadStream(&apos;lines.txt&apos;);readLines(input, func); createWriteStream()createWriteStream方法创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作。 123456789101112131415161718var out = fs.createWriteStream(fileName, &#123; encoding: &apos;utf8&apos;&#125;);out.write(str);out.end();createWriteStream方法和createReadStream方法配合，可以实现拷贝大型文件。function fileCopy(filename1, filename2, done) &#123; var input = fs.createReadStream(filename1); var output = fs.createWriteStream(filename2); input.on(&apos;data&apos;, function(d) &#123; output.write(d); &#125;); input.on(&apos;error&apos;, function(err) &#123; throw err; &#125;); input.on(&apos;end&apos;, function() &#123; output.end(); if (done) done(); &#125;);&#125; 同步还是异步 要在单线种中创建能够处理高并发的高效程序，采用异步，事件驱动的程序是不错的选择。 理解Streamnode.js console 会输出内容到控制台。事实上，console.log内部做了如下处理：在指定的字符串后面加上\\n（换行）字符，并将其写入stdout流中。 process 全局对象中包含了三个流对象。 stdin 标准输入 stdout 标准输出 stderror 标准错误 需求场景描述fs模块允许我们通过Stream API来对数据进行读写操作。与readFile 及 writeFile方法不同，它对内存的分配不是一次完成的。 有一个大文件，文件内容由上百万行逗号分割文本组成。要完整的读取该文件进行解析。意味着要一次性分配很大的内存。更好的方式应该是一次只读取一块内容，以行尾结束符（“\\n”）来切分，然后再逐块进行解析。 Node Stream 就是对上述解决方案的完美实现。 Streamfs.createREadStream方法允许为一个文件创建一个可读的Stream对象。方便理解，举例如下： 123fs.readFile(&apos;xxx.txt&apos;, function(err, contents) &#123; //处理整个文件&#125;); 上面的例子，回调函数必须要等到整个文件读取完毕，载入到RAM，且可用的情况下才会触发。 123456789var stream = fs.createReadStream(&apos;xxx.txt&apos;);stream.on(&apos;data&apos;, function(chunk) &#123; //处理文件的部分内容&#125;)；stream.on(&apos;end&apos;, function() &#123; //文件读取完毕。&#125;) 应用场景 大文件上传 日志记录（操作系统的打开，关闭文件较低效） Stream 继承自EventEmitterdemofs初版demo初级需求 程序在命令行运行。通过终端提供交互给用户输入，输出。 程序启动后，需要显示当前目录下的文件列表。 选择某个文件时，程序需要显示该文件的内容。 选择一个目录时，程序需要显示该目录下的信息。 运行结束后退出程序。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var fs = require(&apos;fs&apos;), colors = require(&apos;colors&apos;), stdin = process.stdin, stdout = process.stdout, path = require(&apos;path&apos;), stats = [], files = fs.readdirSync(process.cwd());function file(i) &#123; var filename = files[i]; fs.stat( path.resolve(__dirname, filename), function (err, stat) &#123; stats[i] = stat; if (stat.isDirectory()) &#123; console.log(` $&#123;i&#125; $&#123;filename&#125;/`.blue); &#125; else &#123; console.log(` $&#123;i&#125; $&#123;filename&#125;`.green); &#125; if (++i == files.length) &#123; read(); &#125; else &#123; file(i); &#125; &#125; );&#125;function read() &#123; console.log(``); stdout.write(` Enter your choice: `.yellow); stdin.resume(); stdin.setEncoding(&apos;utf8&apos;); stdin.on(&apos;data&apos;, option);&#125;function option(data) &#123; var filename = files[Number(data)]; if (!filename) &#123; stdout.write(` Enter your choice: `.red); &#125; else &#123; stdin.pause(); if (stats[Number(data)].isDirectory()) &#123; fs.readdir( path.resolve(__dirname, filename), function(err, files) &#123; console.log(&apos;&apos;); console.log(`($&#123;files.length&#125; files)`); files.forEach(function(file) &#123; console.log(` - $&#123;file&#125;`); &#125;); &#125; ); &#125; else &#123; fs.readFile( path.resolve(__dirname, filename), &apos;utf8&apos;, function (err, data) &#123; console.log(&apos;&apos;); console.log(data.cyan); &#125; ); &#125; &#125;&#125;file(0); ### fs升级demo升级需求 程序在命令行运行。通过终端提供交互给用户输入，输出。 程序启动后，需要显示当前目录下的文件列表。 选择某个文件时，程序需要显示该文件的内容。 选择一个目录时，程序需要显示该目录下的文件列表，且能一直递归下去 运行结束后退出程序。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var fs = require(&apos;fs&apos;), colors = require(&apos;colors&apos;), stdin = process.stdin, stdout = process.stdout, path = require(&apos;path&apos;), stats = [], cwd = process.cwd(), files = fs.readdirSync( cwd );function file(i) &#123; var filename = files[i]; fs.stat( path.resolve(cwd, filename), function (err, stat) &#123; stats[i] = stat; if( stat.isDirectory() ) &#123; console.log(` $&#123;i&#125; $&#123;filename&#125;/`.blue); &#125; else &#123; console.log(` $&#123;i&#125; $&#123;filename&#125;`.green); &#125; if( ++i == files.length ) &#123; read(); &#125; else &#123; file(i); &#125; &#125; );&#125;function read() &#123; console.log(``); stdout.write(` Enter your choice: `.yellow); stdin.resume(); stdin.setEncoding(&apos;utf8&apos;); stdin.removeListener(&apos;data&apos;, option); stdin.on(&apos;data&apos;, option);&#125;function option(data) &#123; var filename = files[Number(data)]; if( !filename ) &#123; stdout.write(` Enter your choice: `.red); &#125; else &#123; stdin.pause(); if( stats[Number(data)].isDirectory() ) &#123; cwd = path.resolve(cwd, filename); fs.readdir( cwd, function(err, subFiles) &#123; files = subFiles; file(0, cwd); &#125; ); &#125; else &#123; fs.readFile( path.resolve(cwd, filename), &apos;utf8&apos;, function(err, data) &#123; console.log(&apos;&apos;); console.log(data.cyan); &#125; ); &#125; &#125;&#125;file(0);","categories":[],"tags":[]},{"title":"performance","slug":"performance","date":"2018-01-21T13:24:33.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2018/01/21/performance/","link":"","permalink":"https://ryansuen.github.io/2018/01/21/performance/","excerpt":"","text":"performance简介Performance接口可以获取到当前页面与性能相关的信息。这个API为测量网站性能，提供以前没有办法做到的精度。 比如，为了得到脚本运行的准确耗时，需要一个高精度时间戳。传统的做法是使用Date对象的getTime方法。 1234567var start = new Date().getTime();// do something herevar now = new Date().getTime();var latency = now - start;console.log(&quot;任务运行时间：&quot; + latency); 上面这种做法有两个不足之处。首先，getTime方法（以及Date对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了；其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。 为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个API，部署在performance对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一），这对于衡量的程序的细微差别，提高程序运行速度很有好处，而且还可以获取后台事件的时间进度。 目前，所有主要浏览器都已经支持performance对象，包括Chrome 20+、Firefox 15+、IE 10+、Opera 15+。 performance.timing对象performance对象的timing属性指向一个对象，它包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时。比如，performance.timing.navigationStart就是浏览器处理当前网页的启动时间。 12Date.now() - performance.timing.navigationStart// 13260687 上面代码表示距离浏览器开始处理当前网页，已经过了13260687毫秒。 下面是另一个例子。 12345var t = performance.timing;var pageloadtime = t.loadEventStart - t.navigationStart;var dns = t.domainLookupEnd - t.domainLookupStart;var tcp = t.connectEnd - t.connectStart;var ttfb = t.responseStart - t.navigationStart; 上面代码依次得到页面加载的耗时、域名解析的耗时、TCP连接的耗时、读取页面第一个字节之前的耗时。 performance.timing对象包含以下属性（全部为只读）： navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 unloadEventEnd：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 redirectStart：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。 requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。 responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。 responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下： 12var t = performance.timing; var pageLoadTime = t.loadEventEnd - t.navigationStart; performance.now()performance.now方法返回当前网页自从performance.timing.navigationStart到当前时间之间的微秒数（毫秒的千分之一）。也就是说，它的精度可以达到100万分之一秒。 12345performance.now() // 23493457.476999998Date.now() - (performance.timing.navigationStart + performance.now())// -0.64306640625 上面代码表示，performance.timing.navigationStart加上performance.now()，近似等于Date.now()，也就是说，Date.now()可以替代performance.now()。但是，前者返回的是毫秒，后者返回的是微秒，所以后者的精度比前者高1000倍。 通过两次调用performance.now方法，可以得到间隔的准确时间，用来衡量某种操作的耗时。 12345var start = performance.now();doTasks();var end = performance.now();console.log(&apos;耗时：&apos; + (end - start) + &apos;微秒。&apos;); performance.mark()mark方法用于为相应的视点做标记。 1window.performance.mark(&apos;mark_fully_loaded&apos;); clearMarks方法用于清除标记，如果不加参数，就表示清除所有标记。 123window.peformance.clearMarks(&apos;mark_fully_loaded&apos;);window.performance.clearMarks(); performance.getEntries()浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。 由于该方法与浏览器处理网页的过程相关，所以只能在浏览器中使用。 12345678window.performance.getEntries()[0]// PerformanceResourceTiming &#123; // responseEnd: 4121.6200000017125, // responseStart: 4120.0690000005125, // requestStart: 3315.355000002455, // ...// &#125; 上面代码返回第一个HTTP请求（即网页的HTML源码）的时间统计信息。该信息以一个高精度时间戳的对象形式返回，每个属性的单位是微秒（microsecond），即百万分之一秒。 performance.navigation对象除了时间信息，performance还可以提供一些用户行为信息，主要都存放在performance.navigation对象上面。 它有两个属性： performance.navigation.type该属性返回一个整数值，表示网页的加载来源，可能有以下4种情况： 0：网页通过点击链接、地址栏输入、表单提交、脚本操作等方式加载，相当于常数performance.navigation.TYPE_NAVIGATENEXT。 1：网页通过“重新加载”按钮或者location.reload()方法加载，相当于常数performance.navigation.TYPE_RELOAD。 2：网页通过“前进”或“后退”按钮加载，相当于常数performance.navigation.TYPE_BACK_FORWARD。 255：任何其他来源的加载，相当于常数performance.navigation.TYPE_UNDEFINED。 performance.navigation.redirectCount该属性表示当前网页经过了多少次重定向跳转。 计算一些性能数据1234567891011121314151617181920212223242526272829303132333435363738394041424344//重定向次数：var redirectCount = navigation &amp;&amp; navigation.redirectCount; //跳转耗时：var redirect = timing.redirectEnd - timing.redirectStart; //APP CACHE 耗时：var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0); //DNS 解析耗时：var dns = timing.domainLookupEnd - timing.domainLookupStart; //TCP 链接耗时：var conn = timing.connectEnd - timing.connectStart; //等待服务器响应耗时（注意是否存在cache）：var request = timing.responseStart - timing.requestStart; //内容加载耗时（注意是否存在cache）:var response = timing.responseEnd - timing.responseStart; //总体网络交互耗时，即开始跳转到服务器资源下载完成：var network = timing.responseEnd - timing.navigationStart; //渲染处理：var processing = (timing.domComplete || timing.domLoading) - timing.domLoading; //抛出 load 事件：var load = timing.loadEventEnd - timing.loadEventStart; //总耗时：var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart; //可交互：var active = timing.domInteractive - timing.navigationStart; //请求响应耗时，即 T0，注意cache：var t0 = timing.responseStart - timing.navigationStart; //首次出现内容（白屏时间），即 T1：(注意是后端渲染还是\b由前端\b渲染)var t1 = timing.domLoading - timing.navigationStart; //内容加载完毕，即 T3：var t3 = timing.loadEventEnd - timing.navigationStart; 理解chrome的Resource Timing时序图请注意：当使用具有跨源资源的 Resource Timing API 时，确保所有资源具有 CORS 标头。 Resource Timing API 提供了与接收各个资源的时间有关的大量详细信息。请求生命周期的主要阶段包括： 重定向 立即开始 startTime。 如果正在发生重定向，redirectStart 也会开始。 如果重定向在本阶段末发生，将采集 redirectEnd。 应用缓存 如果是应用缓存在实现请求，将采集 fetchStart 时间。 DNS domainLookupStart 时间在 DNS 请求开始时采集。 domainLookupEnd 时间在 DNS 请求结束时采集。 TCP connectStart 在初始连接到服务器时采集。 如果正在使用 TLS 或 SSL，secureConnectionStart 将在握手（确保连接安全）开始时开始。 connectEnd 将在到服务器的连接完成时采集。 请求 requestStart 会在对某个资源的请求被发送到服务器后立即采集。 响应 responseStart 是服务器初始响应请求的时间。 responseEnd 是请求结束并且数据完成检索的时间。 在 DevTools 中查看要查看 Network 面板中给定条目完整的耗时信息，您有三种选择。 将鼠标悬停到 Timeline 列下的耗时图表上。这将呈现一个显示完整耗时数据的弹出窗口。 点击任何条目并打开该条目的 Timing 标签。 使用 Resource Timing API 从 JavaScript 检索原始数据。 此代码可以在 DevTools 的 Console 中运行。 它将使用 Network Timing API 检索所有资源。 然后，它将通过查找是否存在名称中包含“style.css”的条目对条目进行过滤。 如果找到，将返回相应条目。 Queuing如果某个请求正在排队，则指示： 请求已被渲染引擎推迟，因为该请求的优先级被视为低于关键资源（例如脚本/样式）的优先级。 图像经常发生这种情况。 请求已被暂停，以等待将要释放的不可用 TCP 套接字。 请求已被暂停，因为在 HTTP 1 上，浏览器仅允许每个源拥有六个 TCP 连接。 生成磁盘缓存条目所用的时间（通常非常迅速） Stalled/Blocking请求等待发送所用的时间。 可以是等待 Queueing 中介绍的任何一个原因。 此外，此时间包含代理协商所用的任何时间。 Proxy Negotiation与代理服务器连接协商所用的时间。 DNS Lookup执行 DNS 查询所用的时间。 页面上的每一个新域都需要完整的往返才能执行 DNS 查询。 Initial Connection / Connecting建立连接所用的时间，包括 TCP 握手/重试和协商 SSL 的时间。 SSL完成 SSL 握手所用的时间。 Request Sent / Sending发出网络请求所用的时间。 通常不到一毫秒。 Waiting (TTFB)等待初始响应所用的时间，也称为至第一字节的时间。 此时间将捕捉到服务器往返的延迟时间，以及等待服务器传送响应所用的时间。 Content Download / Downloading接收响应数据所用的时间。 诊断网络问题通过 Network 面板可以发现大量可能的问题。查找这些问题需要很好地了解客户端与服务器如何通信，以及协议施加的限制。 已被加入队列或已被停止的系列最常见问题是一系列已被加入队列或已被停止的条目。这表明正在从单个网域检索太多的资源。在 HTTP 1.0/1.1 连接上，Chrome 会将每个主机强制设置为最多六个 TCP 连接。如果您一次请求十二个条目，前六个将开始，而后六个将被加入队列。最初的一半完成后，队列中的第一个条目将开始其请求流程。 要为传统的 HTTP 1 流量解决此问题，您需要实现域分片。也就是在您的应用上设置多个子域，以便提供资源。然后，在子域之间平均分配正在提供的资源。 HTTP 1 连接的修复结果不会应用到 HTTP 2 连接上。事实上，前者的结果会影响后者。 如果您部署了 HTTP 2，请不要对您的资源进行域分片，因为它与 HTTP 2 的操作方式相反。在 HTTP 2 中，到服务器的单个 TCP 连接作为多路复用连接。这消除了 HTTP 1 中的六个连接限制，并且可以通过单个连接同时传输多个资源。 至第一字节的漫长时间又称：大片绿色 等待时间长表示至第一字节的时间 (TTFB) 漫长。建议将此值控制在 200 毫秒以下。长 TTFB 会揭示两个主要问题之一。 请执行以下任一操作： 客户端与服务器之间的网络条件较差，或者 服务器应用的响应慢 要解决长 TTFB，首先请尽可能缩减网络。理想的情况是将应用托管在本地，然后查看 TTFB 是否仍然很长。如果仍然很长，则需要优化应用的响应速度。可以是优化数据库查询、为特定部分的内容实现缓存，或者修改您的网络服务器配置。很多原因都可能导致后端缓慢。您需要调查您的软件并找出未满足您的性能预算的内容。 如果本地托管后 TTFB 仍然漫长，那么问题出在您的客户端与服务器之间的网络上。很多事情都可以阻止网络遍历。客户端与服务器之间有许多点，每个点都有其自己的连接限制并可能引发问题。测试时间是否缩短的最简单方法是将您的应用置于其他主机上，并查看 TTFB 是否有所改善。 达到吞吐量能力又称：大片蓝色 如果您看到 Content Download 阶段花费了大量时间，则提高服务器响应或串联不会有任何帮助。首要的解决办法是减少发送的字节数。","categories":[],"tags":[]},{"title":"JSON","slug":"JSON","date":"2017-12-20T22:11:34.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2017/12/21/JSON/","link":"","permalink":"https://ryansuen.github.io/2017/12/21/JSON/","excerpt":"","text":"JSON(JavaScript Object Notation)简介JSON是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 JSON 数据格式与语言无关，脱胎于 JavaScript，但目前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。 JSON出现之前，XML一直是\b互联网传输\b\b结构化数据的标准。然而业界不少人认为XML过于烦琐，冗长。为了解决些问题JSON应机而生。 JSON与XML最大的不同在于XML是一个完整的标记语言，而JSON不是。这使得XML在程序判读上需要比较多的功夫。主要的原因在于XML的设计理念与JSON不同。XML利用标记语言的特性提供了绝佳的延展性（如XPath），在数据存储，扩展及高级检索方面具备对JSON的优势，而JSON则由于比XML更加小巧，以及浏览器的内建快速解析支持，使得其更适用于网络数据传输领域。 关于JSON，最重要的是理解它是一种数据格式，不是一种编程语言。虽然JSON与Javascript有几乎完全相似的语法形式，但JSON并不从\b属于Javascript。并非只有Javascript才\b使用JSON，很多语言都有针对JSON的解析器和序列化器。 它基于 JavaScript 语法，但与之不同：一些JavaScript不是JSON，一些JSON不是JavaScript。参考 JSON：不是JavaScript 的子集。 语法JSON语法可以表示以下三种类型的值： 简单值：使用与Javascript相同的语法，可以在JSON中表示字符串，数值，布尔值和null。注意JSON不支持Javascript中的特殊对象undefined. 对象：一个对象包含一系列无序的名称／值对(pair)，一个对象以{开始，并以}结束。每个名称／值对之间使用,分区。 一个数组是一个值(value)的集合，一个数组以[，并已]结束。值之间使用,分区。 简单值12345//数据值666//字符串“\btesting” \bJSON字符串与Javascript字符串最大的区别在于，JSON字符串必须使用双引号（\b单引号会导致语法错误）。 布尔值\b与null也是JSON的有效形式。\b实际\b应该用它们只是复杂的数据结构当中的一部分。 对象12345678910111213141516//Javascriptvar person = &#123; name: &apos;ryan&apos;, age: 6&#125;;var person = &#123; &quot;name&quot;: &quot;ryan&quot;, &quot;age&quot;: 6&#125;;//JSON&#123; &quot;name&quot;: &quot;ryan&quot;, &quot;age&quot;: 6&#125; JSON中的对象要求给属性加双引号（\b不加或单引号都会导致语法错误\b）。 JSON当中没有变量的\b概念。 JSON没有末尾的分号。 JSON对象最后一个属性不可以有逗号。（对象中嵌套的对象也一样） 数组12345678910111213141516171819202122232425262728293031323334353637383940// javascriptvar array = [25, &quot;hello&quot;, &quot;world&quot;];//JSON[25, &quot;hello&quot;, &quot;world&quot;][ &#123; “\bname”: &quot;name1&quot;, &quot;age&quot;: 1, &quot;detail&quot;: &#123; &quot;aaa&quot;: &quot;aaa&quot;, &quot;bbb&quot;: &quot;bbb&quot; &#125; &#125;, &#123; “\bname”: &quot;name2&quot;, &quot;age&quot;: 2, &quot;detail&quot;: &#123; &quot;aaa&quot;: &quot;aaa&quot;, &quot;bbb&quot;: &quot;bbb&quot; &#125; &#125;, &#123; “\bname”: &quot;name3&quot;, &quot;age&quot;: 3, &quot;detail&quot;: &#123; &quot;aaa&quot;: &quot;aaa&quot;, &quot;bbb&quot;: &quot;bbb&quot; &#125; &#125;, &#123; “\bname”: &quot;name4&quot;, &quot;age&quot;: 4, &quot;detail&quot;: &#123; &quot;aaa&quot;: &quot;aaa&quot;, &quot;bbb&quot;: &quot;bbb&quot; &#125; &#125;,] \b\b数据也没有变量的概念 同样也没有分号 \b解析与序列化(javascript中的\bJSON对象)12345//JSON使用\bbooks[2].title//XMLdoc.getElementsByTagName(&quot;book&quot;)[2].getAtrribute(&quot;title&quot;) 从上也不难理解为什么JSON受开发人员欢迎。 \b\bJavascript早期解析\bJSON\b直接使用eval()对JSON数据进行中值。这样会存在风险，因可能会\b\b执行一些恶意代码。123456//前端老人可能还用过如下方式：var json= eval(&quot;&#123;message:(function ()&#123; window.location=&apos;http://zh.wikipedia.org/wiki/JSON#.E5.AE.89.E5.85.A8.E6.80.A7.E5.95.8F.E9.A1.8C&apos;; &#125;)()&#125;&quot;);var json= eval(&quot;(&quot; + &quot;&#123;message:(function ()&#123; window.location=&apos;http://zh.wikipedia.org/wiki/JSON#.E5.AE.89.E5.85.A8.E6.80.A7.E5.95.8F.E9.A1.8C&apos;; &#125;)()&#125;&quot; + &quot;)&quot;);\b//上面解析的内容就非标准的JSON，存在恶意代码。 \b\b\bjavascript中的JSON\b对象JSON.parse() 作用：解析一个JSON字符串，可选地转换生成的值及其属性，并返回值。 语法 JSON.parse(text[, reviver]) 参数 text:要被解析成JavaScript值的字符串，查看 JSON 对象学习的JSON 语法的说明。 reviver [可选] 如果是一个函数，则规定了原始值如何被解析改造，在被返回之前。 返回值: Object对应给定的JSON文本。 异常: 若被解析的 JSON 字符串是非法的，则会抛出 一个语法错误 异常。123456JSON.parse(&apos;&#123;&#125;&apos;); // &#123;&#125;JSON.parse(&apos;true&apos;); // trueJSON.parse(&apos;&quot;foo&quot;&apos;); // &quot;foo&quot;JSON.parse(&apos;[1, 5, &quot;false&quot;]&apos;); // [1, 5, &quot;false&quot;]JSON.parse(&apos;null&apos;); // nullJSON.parse(&apos;1&apos;); // 1 使用 reviver 函数如果指定了 reviver 函数，则解析出的 JavaScript 值（解析值）会经过一次转换后才将被最终返回（返回值）。更具体点讲就是：解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数，在调用过程中，当前属性所属的对象会作为 this 值，当前属性名和属性值会分别作为第一个和第二个参数传入 reviver 中。如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。 当遍历到最顶层的值（解析值）时，传入 reviver 函数的参数会是空字符串 “”（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了），当前的 this 值会是 {“”: 修改过的解析值}，在编写 reviver 函数时，要注意到这个特例。（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历） 123456789101112131415161718JSON.parse(&apos;&#123;&quot;p&quot;: 5&#125;&apos;, function (k, v) &#123; if(k === &apos;&apos;) return v; // 如果到了最顶层，则直接返回属性值， return v * 2; // 否则将属性值变为原来的 2 倍。&#125;); // &#123; p: 10 &#125;JSON.parse(&apos;&#123;&quot;1&quot;: 1, &quot;2&quot;: 2,&quot;3&quot;: &#123;&quot;4&quot;: 4, &quot;5&quot;: &#123;&quot;6&quot;: 6&#125;&#125;&#125;&apos;, function (k, v) &#123; console.log(k); // 输出当前的属性名，从而得知遍历顺序是从内向外的， // 最后一个属性名会是个空字符串。 return v; // 返回原始属性值，相当于没有传递 reviver 参数。&#125;);// 1// 2// 4// 6// 5// 3 // &quot;&quot; JSON.parse() 不允许用逗号作为结尾123// both will throw a SyntaxErrorJSON.parse(&quot;[1, 2, 3, 4, ]&quot;);JSON.parse(&apos;&#123;&quot;foo&quot; : 1, &#125;&apos;); JSON.stringify() 作用：返回与指定值相对应的一个JSON字符串，可选地仅包含某些属性或以用户定义的方式替换属性值。 语法：JSON.stringify(value[, replacer [, space]]) 参数 value： 将要序列化成 一个JSON 字符串的值。 replacer 【可选】：如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；关于该参数更详细的解释和示例，请参考使用原生的 JSON 对象一文。 space 【可选】：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。 返回值： 一个表示给定值的JSON字符串。 关于序列化，有下面五点注意事项： 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 不可枚举的属性会被忽略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748JSON.stringify(&#123;&#125;); // &apos;&#123;&#125;&apos;JSON.stringify(true); // &apos;true&apos;JSON.stringify(&quot;foo&quot;); // &apos;&quot;foo&quot;&apos;JSON.stringify([1, &quot;false&quot;, false]); // &apos;[1,&quot;false&quot;,false]&apos;JSON.stringify(&#123; x: 5 &#125;); // &apos;&#123;&quot;x&quot;:5&#125;&apos;JSON.stringify(&#123;x: 5, y: 6&#125;); // &quot;&#123;&quot;x&quot;:5,&quot;y&quot;:6&#125;&quot;JSON.stringify([new Number(1), new String(&quot;false&quot;), new Boolean(false)]); // &apos;[1,&quot;false&quot;,false]&apos;JSON.stringify(&#123;x: undefined, y: Object, z: Symbol(&quot;&quot;)&#125;); // &apos;&#123;&#125;&apos;JSON.stringify([undefined, Object, Symbol(&quot;&quot;)]); // &apos;[null,null,null]&apos; JSON.stringify(&#123;[Symbol(&quot;foo&quot;)]: &quot;foo&quot;&#125;); // &apos;&#123;&#125;&apos;JSON.stringify(&#123;[Symbol.for(&quot;foo&quot;)]: &quot;foo&quot;&#125;, [Symbol.for(&quot;foo&quot;)]);// &apos;&#123;&#125;&apos;JSON.stringify( &#123;[Symbol.for(&quot;foo&quot;)]: &quot;foo&quot;&#125;, function (k, v) &#123; if (typeof k === &quot;symbol&quot;)&#123; return &quot;a symbol&quot;; &#125; &#125;);// undefined // 不可枚举的属性默认会被忽略：JSON.stringify( Object.create( null, &#123; x: &#123; value: &apos;x&apos;, enumerable: false &#125;, y: &#123; value: &apos;y&apos;, enumerable: true &#125; &#125; ));// &quot;&#123;&quot;y&quot;:&quot;y&quot;&#125;&quot; replacer参数 eplacer参数可以是一个函数或者一个数组。作为函数，它有两个参数，键(key)值(value)都会被序列化。 1. 如果返回一个 Number, 转换成相应的字符串被添加入JSON字符串。 2. 如果返回一个 String, 该字符串作为属性值被添加入JSON。 3. 如果返回一个 Boolean, &quot;true&quot; 或者 &quot;false&quot;被作为属性值被添加入JSON字符串。 4. 如果返回任何其他对象，该对象递归地序列化成JSON字符串，对每个属性调用replaceer方法。除非该对象是一个函数，这种情况将不会被序列化成JSON字符串。 5. 如果返回undefined，该属性值不会在JSON字符串中输出。 注意: 不能用replacer方法，从数组中移除值(values)，如若返回undefined或者一个函数，将会被null取代。 例子(function)12345678910function replacer(key, value) &#123; if (typeof value === &quot;string&quot;) &#123; return undefined; &#125; return value;&#125;var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;var jsonString = JSON.stringify(foo, replacer);//JSON序列化结果为 &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;. 例子(array)123//如果replacer是一个数组，数组的值代表将被序列化成JSON字符串的属性名。JSON.stringify(foo, [&apos;week&apos;, &apos;month&apos;]); // &apos;&#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;&apos;, 只保留“week”和“month”属性值。 space 参数123456789//space 参数用来控制结果字符串里面的间距。如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格）；如果是一个字符串，则每一级别会比上一级别多缩进用该字符串（或该字符串的前十个字符）。JSON.stringify(&#123; a: 2 &#125;, null, &quot; &quot;); // &apos;&#123;\\n &quot;a&quot;: 2\\n&#125;&apos;//使用制表符（\\t）来缩进：JSON.stringify(&#123; uno: 1, dos : 2 &#125;, null, &apos;\\t&apos;)// &apos;&#123; \\// &quot;uno&quot;: 1, \\// &quot;dos&quot;: 2 \\// &#125;&apos; toJSON 方法123456789//如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：var obj = &#123; foo: &apos;foo&apos;, toJSON: function () &#123; return &apos;bar&apos;; &#125;&#125;;JSON.stringify(obj); // &apos;&quot;bar&quot;&apos;JSON.stringify(&#123;x: obj&#125;); // &apos;&#123;&quot;x&quot;:&quot;bar&quot;&#125;&apos; JSON.stringify用作 JavaScript1234567891011121314151617181920212223//注意JSON不是javascript严格意义上的子集，在JSON中不需要省略两条终线(Line separator和Paragraph separator)但在JavaScript中需要被省略。因此，如果JSON被用作JSONP时，下面方法可以使用：function jsFriendlyJSONStringify (s) &#123; return JSON.stringify(s). replace(/\\u2028/g, &apos;\\\\u2028&apos;). replace(/\\u2029/g, &apos;\\\\u2029&apos;);&#125;var s = &#123; a: String.fromCharCode(0x2028), b: String.fromCharCode(0x2029)&#125;;try &#123; eval(&apos;(&apos; + JSON.stringify(s) + &apos;)&apos;);&#125; catch (e) &#123; console.log(e); // &quot;SyntaxError: unterminated string literal&quot;&#125;// No need for a catcheval(&apos;(&apos; + jsFriendlyJSONStringify(s) + &apos;)&apos;);// console.log in Firefox unescapes the Unicode if// logged to console, so we use alertalert(jsFriendlyJSONStringify(s)); // &#123;&quot;a&quot;:&quot;\\u2028&quot;,&quot;b&quot;:&quot;\\u2029&quot;&#125; 使用 JSON.stringify 结合 localStorage 的例子12345678910111213141516171819202122//一些时候，你想存储用户创建的一个对象，并且，即使在浏览器被关闭后仍能恢复该对象。下面的例子是 JSON.stringify 适用于这种情形的一个样板：// 创建一个示例数据var session = &#123; &apos;screens&apos; : [], &apos;state&apos; : true&#125;;session.screens.push(&#123;&quot;name&quot;:&quot;screenA&quot;, &quot;width&quot;:450, &quot;height&quot;:250&#125;);session.screens.push(&#123;&quot;name&quot;:&quot;screenB&quot;, &quot;width&quot;:650, &quot;height&quot;:350&#125;);session.screens.push(&#123;&quot;name&quot;:&quot;screenC&quot;, &quot;width&quot;:750, &quot;height&quot;:120&#125;);session.screens.push(&#123;&quot;name&quot;:&quot;screenD&quot;, &quot;width&quot;:250, &quot;height&quot;:60&#125;);session.screens.push(&#123;&quot;name&quot;:&quot;screenE&quot;, &quot;width&quot;:390, &quot;height&quot;:120&#125;);session.screens.push(&#123;&quot;name&quot;:&quot;screenF&quot;, &quot;width&quot;:1240, &quot;height&quot;:650&#125;);// 使用 JSON.stringify 转换为 JSON 字符串// 然后使用 localStorage 保存在 session 名称里localStorage.setItem(&apos;session&apos;, JSON.stringify(session));// 然后是如何转换通过 JSON.stringify 生成的字符串，该字符串以 JSON 格式保存在 localStorage 里var restoredSession = JSON.parse(localStorage.getItem(&apos;session&apos;));// 现在 restoredSession 包含了保存在 localStorage 里的对象console.log(restoredSession); 复制对象123var a = &#123;a: 123, b: 234&#125;;var b = JSON.parse(JSON.stringify(a));console.log(a === b); //false PolyfillJSON对象不被旧版本浏览器支持。你可以把下面代码放到脚本的开始位置，这样就可以在那些没有原生支持 JSON 对象的浏览器（如IE6）中使用 JSON对象。 1234567891011121314151617181920212223242526272829303132333435363738if (!window.JSON) &#123; window.JSON = &#123; parse: function(sJSON) &#123; return eval(&apos;(&apos; + sJSON + &apos;)&apos;); &#125;, stringify: (function () &#123; var toString = Object.prototype.toString; var isArray = Array.isArray || function (a) &#123; return toString.call(a) === &apos;[object Array]&apos;; &#125;; var escMap = &#123;&apos;&quot;&apos;: &apos;\\\\&quot;&apos;, &apos;\\\\&apos;: &apos;\\\\\\\\&apos;, &apos;\\b&apos;: &apos;\\\\b&apos;, &apos;\\f&apos;: &apos;\\\\f&apos;, &apos;\\n&apos;: &apos;\\\\n&apos;, &apos;\\r&apos;: &apos;\\\\r&apos;, &apos;\\t&apos;: &apos;\\\\t&apos;&#125;; var escFunc = function (m) &#123; return escMap[m] || &apos;\\\\u&apos; + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); &#125;; var escRE = /[\\\\&quot;\\u0000-\\u001F\\u2028\\u2029]/g; return function stringify(value) &#123; if (value == null) &#123; return &apos;null&apos;; &#125; else if (typeof value === &apos;number&apos;) &#123; return isFinite(value) ? value.toString() : &apos;null&apos;; &#125; else if (typeof value === &apos;boolean&apos;) &#123; return value.toString(); &#125; else if (typeof value === &apos;object&apos;) &#123; if (typeof value.toJSON === &apos;function&apos;) &#123; return stringify(value.toJSON()); &#125; else if (isArray(value)) &#123; var res = &apos;[&apos;; for (var i = 0; i &lt; value.length; i++) res += (i ? &apos;, &apos; : &apos;&apos;) + stringify(value[i]); return res + &apos;]&apos;; &#125; else if (toString.call(value) === &apos;[object Object]&apos;) &#123; var tmp = []; for (var k in value) &#123; if (value.hasOwnProperty(k)) tmp.push(stringify(k) + &apos;: &apos; + stringify(value[k])); &#125; return &apos;&#123;&apos; + tmp.join(&apos;, &apos;) + &apos;&#125;&apos;; &#125; &#125; return &apos;&quot;&apos; + value.toString().replace(escRE, escFunc) + &apos;&quot;&apos;; &#125;; &#125;)() &#125;;&#125; 众所周知，更复杂的JSON对象 polyfills 是[clarinet]https://github.com/dscape/clarinet()Oboe.js JSON2 和 JSON3。","categories":[],"tags":[]},{"title":"深入理解javascript事件","slug":"深入理解javascript事件","date":"2017-11-20T14:53:22.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2017/11/20/深入理解javascript事件/","link":"","permalink":"https://ryansuen.github.io/2017/11/20/深入理解javascript事件/","excerpt":"","text":"事件的调度如果想让 JavaScript 中的某段代码将来再运行，可以将它放在回调中。回调就是一种普通函数，只不过它是传给像 setTimeout 这样的函数，或者绑定为像 document.onready 这样的属性。运行回调时，我们称已触发某事件（譬如延时结束或页面加载完毕）。 当然，可怕的总是那些细节，哪怕是像 setTimeout 这样看起来很简单的东西。对 setTimeout 的描述通常像这样： 给定一个回调及 n 毫秒的延迟，setTimeout 就会在 n 毫秒后运行该回调。 但是，正如我们将在这一节乃至这一章里看到的，以上描述存在严重缺陷。大多数情况下，该描述只能算接近正确，而在其他情况下则完全是谬误。要想真正理解 setTimeout，必须先大体理解 JavaScript事件模型。 现在还是将来在探究 setTimeout 之前，先来看一个简单的例子。该情形常常会迷惑 JavaScript 新手，特别是那些刚刚从 Java 和 Ruby 等多线程语言迁移过来的新手。 123for (var i = 1; i &lt;= 3; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, 0);&#125;; 444 大多数刚接触 JavaScript 语言的人都会认为以上循环会输出 1，2，3，或者重复输出这 3 个数字，因为这里的 3 次延时都抢着要第一个触发（每次暂停都调度为 0 毫秒后到时）。 要理解为什么输出是 4，4，4，需要知道以下 3 件事。 这里只有一个名为 i 的变量，其作用域由声明语句 var i 定义（该声明语句在不经意间让 i 的作用域不是循环内部，而是扩散至蕴含循环的那个最内侧函数）。 循环结束后，i===4 一直递增，直到不再满足条件 i&lt;=3 为止。 JavaScript 事件处理器在线程空闲之前不会运行。 线程的阻塞123456var start = new Date;setTimeout(function()&#123; var end = new Date; console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);&#125;, 500);while (new Date - start &lt; 1000) &#123;&#125;; 按照多线程的思维定势，我会预计 500 毫秒后计时函数就会运行。不过这要求中断欲持续整整一秒钟的循环。如果运行代码，会得到类似这样的结果： Time elapsed: 1002ms 大家得到的数字可能会稍有不同，这是因为 setTimeout 和 setInterval一样，其计时精度要比我们的期望值差很多（请参阅1.2.2节）。不过，这个数字肯定至少是 1000，因为 setTimeout 回调在 while循环结束运行之前不可能被触发。 那么，如果 setTimeout 没有使用另一个线程，那它到底在做什么呢？ 队列调用 setTimeout 的时候，会有一个延时事件排入队列。然后setTimeout 调用之后的那行代码运行，接着是再下一行代码，直到再也没有任何代码。这时 JavaScript 虚拟机才会问：“队列里都有谁啊？” 如果队列中至少有一个事件适合于“触发”（就像 1000 毫秒之前设定好的那个为期 500 毫秒的延时事件），则虚拟机会挑选一个事件，并调用此事件的处理器（譬如传给 setTimeout 的那个函数）。事件处理器返回后，我们又回到队列处。 输入事件的工作方式完全一样：用户单击一个已附加有单击事件处理器的 DOM（Document Object Model，文档对象模型）元素时，会有一个单击事件排入队列。但是，该单击事件处理器要等到当前所有正在运行的代码均已结束后（可能还要等其他此前已排队的事件也依次结束）才会执行。因此，使用 JavaScript 的那些网页一不小心就会变得毫无反应。 你可能听过事件循环这个术语，它是用于描述队列工作方式的。所谓事件循环，就像代码从一个循环中不断取出而运行一样：1234runYourScript();while (atLeastOneEventIsQueued) &#123; fireNextQueuedEvent();&#125;; 这隐含着一个意思，即触发的每个事件都会位于堆栈轨迹的底部。 事件的易调度性是 JavaScript 语言最大的特色之一。像 setTimeout这样的异步函数只是简单地做延迟执行，而不是孵化新的线程。JavaScript 代码永远不会被中断，这是因为代码在运行期间只需要排队事件即可，而这些事件在代码运行结束之前不会被触发。 异步函数的类型每一种 JavaScript 环境都有自己的异步函数集。有些函数，如setTimeout 和 setInterval，是各种 JavaScript 环境普遍都有的。另一些函数则专属于某些浏览器或某几种服务器端框架。JavaScript环境提供的异步函数通常可以分为两大类：I/O 函数和计时函数。如果想在应用中定义复杂的异步行为，就要使用这两类异步函数作为基本的构造块。 异步的I/O函数创造 Node.js，并不是为了人们能在服务器上运行 JavaScript，仅仅是因为 Ryan Dahl 想要一个建立在某高级语言之上的事件驱动型服务器框架。JavaScript 碰巧就是适合干这个的语言。为什么？因为 JavaScript语言可以完美地实现非阻塞式 I/O。 123456var ajaxRequest = new XMLHttpRequest;ajaxRequest.open(&apos;GET&apos;, url);ajaxRequest.send(null);while (ajaxRequest.readyState === XMLHttpRequest.UNSENT) &#123; // readyState 在循环返回之前不会有更改。&#125;; 相反，我们需要附加一个事件处理器，随即返回事件队列。123456var ajaxRequest = new XMLHttpRequest;ajaxRequest.open(&apos;GET&apos;, url);ajaxRequest.send(null);ajaxRequest.onreadystatechange = function() &#123; // ...&#125;; 就是这么回事。不论是在等待用户的按键行为，还是在等待远程服务器的批量数据，所需要做的就是定义一个回调，除非 JavaScript 环境提供的某个同步 I/O 函数已经替我们完成了阻塞。 在浏览器端，Ajax 方法有一个可设置为 false 的 async 选项（但永远、永远别这么做），这会挂起整个浏览器窗格直到收到应答为止。在 Node.js 中，同步的 API 方法在名称上会有明确的标示，譬如fs.readFileSync。编写短小的脚本时，这些同步方法会很方便。但是，如果所编写的应用需要处理并行的多个请求或多项操作，则应该避免使用它们。可在今天，还有哪个应用不是这样的呢？ 有些 I/O 函数既有同步效应，也有异步效应。举例来说，在现代浏览器中操纵 DOM 对象时，从脚本角度看，更改是即时生效的，但从视效角度看，在返回事件队列之前不会渲染这些 DOM 对象更改。这可以防止 DOM 对象被渲染成不一致的状态。关于这点，可访问http://jsfiddle.net/ TrevorBurnham/SNBYV/，查看一个简单的演示。 console.log是异步的吗？ WebKit的console.log由于表现出异步行为而让很多开发者惊诧不已。在Chrome或Safari中，以下这段代码会在控制台记录 123var obj = &#123;&#125;;console.log(obj);obj.foo = &apos;bar&apos;; 怎么会这样？WebKit的console.log并没有立即拍摄对象快照，相反，它只存储了一个指向对象的引用，然后在代码返回事件队列时才去拍摄快照。 Node的console.log是另一回事，它是严格同步的，因此同样的代码输出的却为{}。 JavaScript 采用了非阻塞式 I/O，这对新手来说是最大的一个障碍，但这同样也是该语言的核心优势之一。有了非阻塞式 I/O，就能自然而然地写出高效的基于事件的代码。 异步的计时函数我们已经看到，异步函数非常适合用于 I/O 操作，但有些时候，我们仅仅是因为需要异步而想要异步性。换句话说，我们想让一个函数在将来某个时刻再运行——这样的函数可能是为了作动画或模拟。基于时间的事件涉及两个著名的函数，即 setTimeout 与 setInterval。 遗憾的是，这两个著名的计时器函数都有自己的一些缺陷。其中有个缺陷是无法弥补的：当同一个 JavaScript进程正运行着代码时，任何 JavaScript 计时函数都无法使其他代码运行起来。但是，即便容忍了这一局限性，setTimeout 及 setInterval的不确定性也会令人犯怵。下面是一个示例。 12345678910var fireCount = 0;var start = new Date;var timer = setInterval(function() &#123; if (new Date-start &gt; 1000) &#123; clearInterval(timer); console.log(fireCount); return; &#125; fireCount++;&#125;, 0); 如果使用 setInterval 调度事件且延迟设定为 0 毫秒，则会尽可能频繁地运行此事件，对吗？那么，在运行于高速英特尔 i7 处理器之上的现代浏览器中，此事件的触发频率到底如何呢？ 大约为 200 次/秒。这是 Chrome、Safari 和 Firefox 等浏览器的平均值。在 Node 环境下，此事件的触发频率大约能达到 1000 次/秒。（若使用setTimeout 来调度事件，重复这些实验也会得到类似的结果。）作为对比，如果将setInterval替换成简单的while循环，则在Chrome中此事件的触发频率将达到 400 万次/秒，而在 Node 中会达到 500 万次/秒！ 这是怎么回事？最后我们发现，setTimeout 和 setInterval 就是想设计成慢吞吞的！事实上，HTML 规范（这是所有主要浏览器都遵守的规范）推行的延时/时隔的最小值就是 4 毫秒！① 那么，如果需要更细粒度的计时，该怎么办呢？有些运行时环境提供了备选方案。 在 Node 中，process.nextTick 允许将事件调度成尽可能快地触发。对于笔者的系统，process.nextTick 事件的触发频率可以超过 10 万次/秒。 一些现代浏览器（含 IE9+）带有一个 requestAnimationFrame函数。此函数有两个目标：一方面，它允许以 60+帧/秒的速度运行JavaScript 动画；另一方面，它又避免后台选项卡运行这些动画，从而节约 CPU 周期。在最新版的 Chrome 浏览器中，甚至能实现亚毫秒级的精度。 尽管这些计时函数是异步 JavaScript 混饭吃的家伙什儿，但永远不要忘记，setTimeout 和 setInterval 就是些不精确的计时工具。在Node中，如果只是想产生一个短时延迟，请使用 process.nextTick。在浏览器端，请尝试使用垫片技术（ shim ） ③ ：在支持requestAnimationFrame 的浏览器中，推荐使用requestAnimationFrame；在不支持 requestAnimationFrame 的浏览器中，则退而使用 setTimeout。 到这里，关于 JavaScript 基本异步函数的简要概览就结束了。但怎样才能知道一个函数到底何时异步呢？下一节中，我们在亲自编写异步函数的同时再思考这个问题。","categories":[],"tags":[]},{"title":"从http(s) request router理解web","slug":"从http-s-request-router理解web","date":"2017-11-10T05:45:04.000Z","updated":"2019-03-05T14:45:54.000Z","comments":true,"path":"2017/11/10/从http-s-request-router理解web/","link":"","permalink":"https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/","excerpt":"","text":"如何定义路由（router）电讯网络设备路由器（router）路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。 http(s) request router（应用层） URI vs URL网址/链接URI(Uniform Resource Identifier/统一资源标识符)，URI用字符串标识某一互关网资源。支持30多种协议方案（http,https,ftp,file,mailto 等等 ）。 URL(Uniform Resource Locator/统一资源定位符)，URL标识资源的地点。 URL是URI的子集。 uri example123456789101112131415ftp://linghit.com/shunli/lunar.jsonhttp://zxcs.linghit.com/indexpage/index.htmlmailto:sunyi@linghit.comtel:+1-388-888-8888telnet://192.168.1.123https://www.eather.com/get?code=1001//绝对URIhttps://zxcs.linghit.com/query（cgi）//绝对URLhttps://zxcs.linghit.com/forecast.images/banner.png//相对URIlocation.href = &apos;/api/v2/order/query&apos; URI格式格式协议名://用户名:密码@服务器地址:端口/带层次的文件路径?查询字符串#文件片段标识符 如果类比vue-router,react-router的路由配置，带层次的文件路径可以翻译成嵌套关系:12345678910React.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;messages/:id&quot; component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 通过上面的配置，这个应用知道如何渲染下面四个 URL： URL 组件 / App /about App -&gt; About /inbox App -&gt; Inbox /inbox/messages/:id App -&gt; Inbox -&gt; Message 案例https://root:123456@www.zxcs.linghit.com:80/dir1/dir2/index.html?querya=1&amp;queryb=2#name 登录认证信息可选，端口号可先，无就用默认。 静态网站定义在网站设计中，纯粹HTML格式的网页通常被称为“静态网页”，早期的网站一般都是由静态网页制作的。 静态网页的网址形式通常为：也就是以.htm、.html、.shtml、.xml等为后后缀的。在HTML格式的网页上，也可以出现各种动态的效果，如.GIF格式的动画、FLASH、滚动字母等，这些“动态效果”只是视觉上的。 静态网页的特点 静态网页每个网页都有一个固定的URL，且网页URL以.htm、.html、.shtml等常见形式为后缀，而不含有“？”； 网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件； 静态网页的内容相对稳定，因此容易被搜索引擎检索； 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难； 静态网页的交互性较差，在功能方面有较大的限制。 demo: https://microbotteam.github.io(/index.html) http://demo.static.web.com(/index.html) 动态网站定义动态网站并不是指具有动画功能的网站，而是指网站内容可根据不同情况动态变更的网站，一般情况下动态网站通过数据库进行架构。 动态网站除了要设计网页外，还要通过数据库和编程序来使网站具有更多自动的和高级的功能。动态网站体现在网页一般是以asp，jsp，php，aspx等结束，而静态网页一般是HTML（标准通用标记语言的子集）结尾，动态网站服务器空间配置要比静态的网页要求高，费用也相应的高，不过动态网页利于网站内容的更新，适合企业建站。动态是相对于静态网站而言。 动态网站的特点 动态网站可以实现交互功能，如用户注册、信息发布、产品展示、订单管理等等； 动态网页并不是独立存在于服务器的网页文件，而是浏览器发出请求时才反馈网页； 动态网页中包含有服务器端脚本，所以页面文件名常以asp、jsp、php等为后缀。但也可以使用URL静态化技术，使网页后缀显示为HTML。所以不能以页面文件的后缀作为判断网站的动态和静态的唯一标准。 动态网页由于需要数据库处理，所以动态网站的访问速度大大减慢； 动态网页由于存在特殊代码，所以相比较静态网页，其对搜索引擎的友好程度相对要弱一些。但随着计算机性能的提升以及网络带宽的提升，最后两条已经基本得到解决。 简单的后端路由代码12345678910111213141516171819202122232425262728293031323334353637383940414243const http = require(&apos;http&apos;)const fs = require(&apos;fs&apos;)const httpPort = 3000function simpleRouter(ctx, url) &#123; let res; if (/query/i.test(url)) &#123; res = ` &lt;h1&gt;query&lt;/h1&gt; &lt;h2&gt;$&#123;url&#125;&lt;/h2&gt; `; &#125; else if (/date/i.test(url)) &#123; res = ` &lt;h1&gt;date&lt;/h1&gt; &lt;h2&gt;$&#123;new Date().toString()&#125;&lt;/h2&gt; `; &#125; else if (&apos;/test.html&apos; === url) &#123; res = fs.readFileSync(&apos;test.html&apos;, &apos;utf-8&apos;, (err, content) =&gt; &#123; if (err) &#123; console.log(err); &#125; &#125;) &#125; else &#123; res = &apos;404&apos;; &#125; return res;&#125;http.createServer((req, res) =&gt; &#123; let url = req.url, response; res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos; &#125;) response = simpleRouter(res, url); res.end(response);&#125;).listen(httpPort, () =&gt; &#123; console.log(&apos;Server listening on: http://localhost:%s&apos;, httpPort)&#125;) 在线nodejs代理代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const Koa = require(&apos;koa&apos;);const serve = require(&apos;koa-static-server&apos;);const router = require(&apos;koa-router&apos;)();const app = new Koa();const path = require(&apos;path&apos;);const koaBody = require(&apos;koa-body&apos;);const request = require(&apos;request&apos;);const rp = require(&apos;request-promise&apos;);app.use( router.routes() ).use( router.allowedMethods() );router.all( &apos;*&apos;, koaBody(), async function(ctx, next) &#123; let url = ctx.request.url, proxy = &apos;http://sandbox.zxcs.linghit.com&apos;; method = ctx.request.method, referer = ctx.request.header.referer, api = `$&#123;proxy&#125;$&#123;url&#125;`; if( /api/i.test(url) ) &#123; if( &apos;GET&apos; === method ) &#123; let result = await new Promise( (resolve, reject) =&gt; &#123; request.get(api, (err, res, body) =&gt; &#123; if( err ) &#123; reject(err); &#125; else &#123; resolve(body); &#125; &#125;); &#125; ); ctx.body = result; &#125; else if(&apos;POST&apos; === method) &#123; let result = await new Promise( (resolve, reject) =&gt; &#123; request.post(&#123; url: api, form: ctx.request.body &#125;, (err, res, body) =&gt; &#123; if( err ) &#123; reject(err); &#125; else &#123; resolve(body); &#125; &#125;); &#125; ); ctx.body = result; &#125; &#125; else &#123; if( /payment/i.test(url) ) &#123; let result = await new Promise( (resolve, reject) =&gt; &#123; request.get(api, (err, res, body) =&gt; &#123; if( err ) &#123; reject(err); &#125; else &#123; resolve(body); &#125; &#125;); &#125; ); if(/page-result/img.test(result) ) &#123; let new_referer = referer.substring(0, (referer.lastIndexOf(&apos;/&apos;) + 1 ) ), query = url.substring( url.indexOf(&apos;?&apos;) ), result = /BZJP/i.test(url) ? &apos;resultQt.html&apos; : result.html; ctx.redirect(`$&#123;new_referer&#125;$&#123;result&#125;$&#123;query&#125;`); &#125; ctx.body = result; &#125; else &#123; await next(); &#125; &#125; &#125;);app.use( serve(&#123; rootDir: path.join(__dirname, &apos;../public/&apos;) &#125;));let port = 80;app.listen(port, () =&gt; &#123; console.log(&apos;&apos;); console.log(&apos;--------------------------------&apos;); console.log(&apos;&apos;); console.log(`proxy start on prot $&#123;port&#125;`); console.log(&apos;&apos;); console.log(&apos;--------------------------------&apos;); console.log(&apos;&apos;);&#125;); #文件片段标识符(hash)了解http协议就会知道，url的组成部分有很多，譬如协议、主机名、资源路径、查询字段等等，其中包含一个称之为片段的部分，以“#”为标识。 例如： http://www.gmail.com/text/#123，123便是url中的hash部分。 打开控制台，输入 location.hash，你可以得到当前url的hash部分（如果当前url不存在hash则返回空字符串）。接下来，输入 location.hash = ‘123’，会发现浏览器地址栏的url变了，末尾增加了’#123’字段，并且，页面没有被重新刷新。很显然，这很符合我们的要求。 ajax的出现可以异步无刷新改变页面内容（太熟悉了， 略过） history1234567//向前和向后跳转window.history.forward();window.history.back();//跳转到 history 中指定的一个点window.history.go(-1); //back()window.history.go(1); //forward() history HTML5 api history.pushState()//添加历史记录条目 history.replaceState()//修改历史记录条目 window.onpopstate//上面两方法与其配合使用 使用 history.pushState() 可以改变referrer，它在用户发送 XMLHttpRequest 请求时在HTTP头部使用，改变state后创建的 XMLHttpRequest 对象的referrer都会被改变。因为referrer是标识 /创建XMLHttpRequest对象时/this 所代表的/window对象中document的/URL。 pushState() 方法pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容： 状态对象 - 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。 状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage. 标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。 在某种意义上，调用 pushState() 与 设置 window.location = “#foo” 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点： 新的 URL 可以是与当前URL同源的任意URL 。而设置 window.location 仅当你只修改了哈希值时才保持同一个 document。 如果需要，你可以不必改变URL。而设置 window.location = “#foo”;在当前哈希不是 #foo 的情况下， 仅仅是新建了一个新的历史记录项。 你可以为新的历史记录项关联任意数据。而基于哈希值的方式，则必须将所有相关数据编码到一个短字符串里。 假如 标题 在之后会被浏览器用到，那么这个数据是可以被使用的（哈希则不然）。 注意 pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。 pushState() 方法的例子假设在 http://mozilla.org/foo.html 中执行了以下 JavaScript 代码: 12var stateObj = &#123; foo: &quot;bar&quot; &#125;;history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;); 这将使浏览器地址栏显示为 http://mozilla.org/bar.html，但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在。 假设现在用户又访问了 http://google.com，然后点击了返回按钮。此时，地址栏将显示 http://mozilla.org/bar.html，同时页面会触发 popstate 事件，事件对象state中包含了 stateObj 的一份拷贝。页面本身与 foo.html 一样，尽管其在 popstate 事件中可能会修改自身的内容。 如果我们再次点击返回按钮，页面URL会变为http://mozilla.org/foo.html，文档对象document会触发另外一个 popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。 replaceState() 方法history.replaceState() 的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个。 注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。 replaceState()的使用场景在于为了响应用户操作，你想要更新状态对象state或者当前历史记录的URL。 replaceState() 方法示例假设 http://mozilla.org/foo.html 执行了如下JavaScript代码：12var stateObj = &#123; foo: &quot;bar&quot; &#125;;history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;); 然后，假设http://mozilla.org/bar.html执行了如下 JavaScript： 1history.replaceState(stateObj, &quot;page 3&quot;, &quot;bar2.html&quot;); 这将会导致地址栏显示http://mozilla.org/bar2.html,，但是浏览器并不会去加载bar2.html 甚至都不需要检查 bar2.html 是否存在。 假设现在用户重新导向到了http://www.microsoft.com，然后点击了回退按按钮。这里，地址栏会显示http://mozilla.org/bar2.html。加入用户再次点击回退按钮，地址栏会显示http://mozilla.org/foo.html，完全跳过了abar.html。 window.onpopstatewindow.onpopstate是popstate事件在window对象上的事件处理程序. 每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝. 调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法). 当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会. popstate事件示例12345678910window.onpopstate = function(event) &#123; alert(&quot;location: &quot; + document.location + &quot;, state: &quot; + JSON.stringify(event.state));&#125;;//绑定事件处理函数. history.pushState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;?page=1&quot;); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1history.pushState(&#123;page: 2&#125;, &quot;title 2&quot;, &quot;?page=2&quot;); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2history.replaceState(&#123;page: 3&#125;, &quot;title 3&quot;, &quot;?page=3&quot;); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3history.back(); // 弹出 &quot;location: http://example.com/example.html?page=1, state: &#123;&quot;page&quot;:1&#125;&quot;history.back(); // 弹出 &quot;location: http://example.com/example.html, state: nullhistory.go(2); // 弹出 &quot;location: http://example.com/example.html?page=3, state: &#123;&quot;page&quot;:3&#125; history HTML5 api 实际应用将首次打开的网页返回到我们预期的网页易起问的入口为：yd.linghit.com 易起问的老师页面地址：yd.linghit.com/home/user/index?answer_id=250 这两个链接都可以直接作为外链让用户点击后进入对应的页面，正常情况下以微信为列，进入页面不跳转至其他页面点击手机的返回键，页面会关闭直接返回到进行页面的地方。老板觉得这样不太好，应该点击返回键后调到首页再退出。。。。。。1234567891011121314151617181920// document.referrer 表示当前文档的来源，即当前文档是从那个文档打开的url，// 抓包发现从微信直接进来的链接来源referrer是null，从网页内部跳转的是正常的，所以通过判断referrer来判断是否从微信直接跳进来进行处理，对于正常页面跳转不做处理 if(!document.referrer)&#123; if( window.history &amp;&amp; window.history.pushState )&#123; // 压入历史记录状态 history.pushState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;&quot;); // 只有使用pushState和replaceState才能监听popstate后退事件 window.addEventListener(&quot;popstate&quot;, function () &#123; // 后退时把当前的历史状态改为你要跳转的页面，防止多次回退又回来的问题 history.replaceState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;/home/index/index&quot;); // 这里就可以处理自己的事情了 location.href = &quot;/home/index/index&quot;; &#125;); &#125; &#125; 当用户点击返回的时候作一些挽留操作12345678910111213141516171819202122232425//popstate自动触发的bug（目前暂时发现在iPhone6可以还原这个bug）(function() &#123; if(window.history.pushState)&#123; //初始时如果没有state，先加一个进去，防止popstate不触发 if(!window.history.state)&#123; window.history.pushState(&apos;init&apos;, &apos;&apos;, &apos;&apos;); &#125; //为当前页面history压入一个state window.history.replaceState(&#123;hasState: true&#125;, &apos;&apos;, &apos;&apos;); console.log(&apos;push state over&apos;); window.addEventListener(&apos;load&apos;, function() &#123; setTimeout(function() &#123; //监听页面的popstate事件。此事件一般在用户点击浏览器后退或前进按钮时触发。 window.addEventListener(&apos;popstate&apos;, function(e) &#123; console.log(&apos;popstate trigger.&apos;); //侦测是用户触发的操作, 处理自定义逻辑，弹窗或其他 alert(&apos;浏览器后退！&apos;); &#125;, false); &#125;, 0); &#125;); &#125;&#125;)(); pajx(pushState + ajax) 开始接近前端路由了http://demo.static.web.com/pjax.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;pjax&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;pjax page!&lt;/h1&gt; &lt;/div&gt; &lt;nav&gt; &lt;ul id=&quot;nav-box&quot;&gt; &lt;li data-index=&quot;part1.html&quot; class=&quot;todo&quot; class=&quot;active&quot;&gt;part1&lt;/li&gt; &lt;li data-index=&quot;part2.html&quot;&gt;part2&lt;/li&gt; &lt;li data-index=&quot;part3.html&quot;&gt;part3&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section id=&quot;page-containter&quot;&gt; &lt;/section&gt; &lt;script&gt; (function() &#123; var setContent = function(content) &#123; var $container = document.getElementById(&apos;page-containter&apos;); $container.innerHTML = content; &#125;; var makeRequest = function makeRequest(options) &#123; httpRequest = new XMLHttpRequest(); if (!httpRequest) &#123; console.error(&apos;Giving up :( Cannot create an XMLHTTP instance&apos;); return false; &#125; httpRequest.onreadystatechange = function() &#123; if (httpRequest.readyState === XMLHttpRequest.DONE) &#123; if (httpRequest.status === 200) &#123; options.cb(httpRequest.responseText); &#125; else &#123; console.error(&apos;There was a problem with the request.&apos;); &#125; &#125; &#125;; httpRequest.open(&apos;GET&apos;, options.url || &apos;part1.html&apos;); httpRequest.send(); &#125; //页面初始化 var init = function() &#123; makeRequest(&#123; url: location.search.replace(&apos;?&apos;, &apos;&apos;) || &apos;part1.html&apos;, cb: function(res) &#123; setContent(res); &#125; &#125;); &#125;; init(); //导航事件 (function() &#123; var $box = document.getElementById(&apos;nav-box&apos;); $box.addEventListener(&apos;click&apos;, function clickCb(e) &#123; var urlIndex = e.target.getAttribute(&apos;data-index&apos;); makeRequest(&#123; url: urlIndex, cb: function(res) &#123; window.history.pushState(&#123; page: urlIndex &#125;, &apos;&apos;, &apos;?&apos; + urlIndex); setContent(res); &#125; &#125;); &#125;, false); &#125;)(); if (window.history.pushState) &#123; //初始时如果没有state，先加一个进去，防止popstate不触发 if (!window.history.state) &#123; window.history.pushState(&#123; page: &apos;part1.html&apos; &#125;, &apos;&apos;, &apos;?part1.html&apos;); &#125; window.addEventListener(&apos;load&apos;, function() &#123; setTimeout(function() &#123; //监听页面的popstate事件。此事件一般在用户点击浏览器后退或前进按钮时触发。 window.addEventListener(&apos;popstate&apos;, function(e) &#123; e.state &amp;&amp; e.state.page &amp;&amp; makeRequest(&#123; url: e.state.page, cb: function(res) &#123; setContent(res); &#125; &#125;); &#125;, false); &#125;, 0); &#125;); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优点： 减轻服务端压力 按需请求，每次只需加载页面的部分内容，而不用重复加载一些公共的资源文件和不变的页面结构，大大减小了数据请求量，以减轻对服务器的带宽和性能压力，还大大提升了页面的加载速度。 优化页面跳转体验 常规页面跳转需要重新加载画面上的内容，会有明显的闪烁，而且往往和跳转前的页面没有连贯性，用户体验不是很好。如果再遇上页面比较庞大、网速又不是很好的情况，用户体验就更加雪上加霜了。使用pjax后，由于只刷新部分页面，切换效果更加流畅，而且可以定制过度动画，在等待页面加载的时候体验就比较舒服了。 缺点： 不支持一些低版本的浏览器(如IE系列) pjax使用了pushState来改变地址栏的url，这是html5中history的新特性，在某些旧版浏览器中可能不支持。不过pjax会进行判断，功能不适用的时候会执行默认的页面跳转操作。 使服务端处理变得复杂 要做到普通请求返回完整页面，而pjax请求只返回部分页面，服务端就需要做一些特殊处理，当然这对于设计良好的后端框架来说，添加一些统一处理还是比较容易的，自然也没太大问题。另外，即使后台不做处理，设置pjax的fragment参数来达到同样的效果。 综合来看，pajx的优点很强势，缺点也几乎可以忽略，还是非常值得推荐的，尤其是类似博客这种大部分情况下只有主体内容变化的网站。关键它使用简单、学习成本小，即时全站只有极个别页面能用得到，尝试下没什么损失。pjax的github主页介绍的已经很详细了，想了解更多可以看下源码。 https://github.com/welefen/pjax前端路由什么是前端路由前端路由，拥有这样一种能力：客户端浏览器可以不依赖服务端，根据不同的URL渲染不同的视图页面。 前端路由的存在合理性在Ajax之剑还未亮出，前端仍处于襁褓之中的时候，路由的工作交给了后端。在进行页面切换的时候，浏览器发送不同的url请求；服务器接收到浏览器的请求时，通过解析不同的url去拼接需要的html或者模板，然后将结果返回给浏览器端进行渲染。 服务器端路由也是不落俗套的有利亦有弊。它的好处是安全性更高，更严格得控制页面的展现。这在某些场景中是很有用的，譬如下单支付流程，每一步只有在上一步成功执行之后才能抵达。这在服务器端可以为每一步流程添加验证机制，只有验证通过才返回正确的页面。那么前端路由不能实现每一步的验证？自然不是，姑且相信你的代码可以写的很严谨，保证正常情况下流程不会错，但是另一个不得不面对的事实是：前端是毫无安全性可言的。用户可以肆意修改代码来进入不同的流程，你可能会为此添加不少的处理逻辑。相较之下，当然是后端控制页面的进入权限更为安全和简便。 另一方面，后端路由无疑增加了服务器端的负荷，并且需要reload页面，用户体验其实不佳。 这样，前端路由就有用武之地了。首先，它的出现无疑减轻了服务器端的压力。特别是对于一个比较复杂的应用来讲，或者更确切的说，对于拥有一个复杂路由系统的应用来说，服务器端需要为每一个不同的url执行一段处理逻辑在高并发的情况下实在有点不堪重负；其次，页面的切换可以不需要刷新整个页面了，没有网络延迟，没有闪烁刷新，提升了用户体验。 前端路由实现方式 在页面不刷新的前提下实现url变化 捕捉到url的变化，以便执行页面替换逻辑 如何实现更新url并且页面不刷新 利用url中的hash字段； 使用html5提供的history API。 如何跟踪url的变化： hash + window.onhashchange history HTML5 api + window.onpopState 低版本不支持hashchange1234567891011121314151617181920212223242526272829(function(window) &#123; // 如果浏览器原生支持该事件,则退出 if ( &quot;onhashchange&quot; in window.document.body ) &#123; return; &#125; var location = window.location, oldURL = location.href, oldHash = location.hash; // 每隔100ms检测一下location.hash是否发生变化 setInterval(function() &#123; var newURL = location.href, newHash = location.hash; // 如果hash发生了变化,且绑定了处理函数... if ( newHash != oldHash &amp;&amp; typeof window.onhashchange === &quot;function&quot; ) &#123; // execute the handler window.onhashchange(&#123; type: &quot;hashchange&quot;, oldURL: oldURL, newURL: newURL &#125;); oldURL = newURL; oldHash = newHash; &#125; &#125;, 100);&#125;)(window); 低版本不支持hisotry HTML5 apihttps://github.com/browserstate/history.js/react-routerHistoriesReact Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。 常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。 browserHistory hashHistory createMemoryHistory你可以从 React Router 中引入它们： 12// JavaScript 模块导入（译者注：ES6 形式）import &#123; browserHistory &#125; from &apos;react-router&apos; 然后将它们传递给: 1234render( &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById(&apos;app&apos;)) browserHistoryBrowser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。 服务器配置服务器需要做好处理 URL 的准备。处理应用启动最初的 / 这样的请求应该没问题，但当用户来回跳转并在 /accounts/123 刷新时，服务器就会收到来自 /accounts/123 的请求，这时你需要处理这个 URL 并在响应中包含 JavaScript 应用代码。 一个 express 的应用可能看起来像这样的： 12345678910111213141516const express = require(&apos;express&apos;)const path = require(&apos;path&apos;)const port = process.env.PORT || 8080const app = express()// 通常用于加载静态资源app.use(express.static(__dirname + &apos;/public&apos;))// 在你应用 JavaScript 文件中包含了一个 script 标签// 的 index.html 中处理任何一个 routeapp.get(&apos;*&apos;, function (request, response)&#123; response.sendFile(path.resolve(__dirname, &apos;public&apos;, &apos;index.html&apos;))&#125;)app.listen(port)console.log(&quot;server started on port &quot; + port) 如果你的服务器是 nginx，请使用 try_files 指令： 123456server &#123; ... location / &#123; try_files $uri /index.html &#125;&#125; 当在服务器上找不到其他文件时，这可以让 nginx 服务器提供静态文件服务并指向index.html 文件。 对于Apache服务器也有类似的方式，创建一个.htaccess文件在你的文件根目录下： 12345RewriteBase /RewriteRule ^index\\.html$ - [L]RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . /index.html [L] IE8, IE9 支持情况如果我们能使用浏览器自带的 window.history API，那么我们的特性就可以被浏览器所检测到。如果不能，那么任何调用跳转的应用就会导致 全页面刷新，它允许在构建应用和更新浏览器时会有一个更好的用户体验，但仍然支持的是旧版的。 你可能会想为什么我们不后退到 hash history，问题是这些 URL 是不确定的。如果一个访客在 hash history 和 browser history 上共享一个 URL，然后他们也共享同一个后退功能，最后我们会以产生笛卡尔积数量级的、无限多的 URL 而崩溃。 hashHistoryHash history 使用 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由。 我应该使用 createHashHistory吗？Hash history不需要服务器任何配置就可以运行，如果你刚刚入门，那就使用它吧。但是我们不推荐在实际线上环境中用到它，因为每一个 web 应用都应该渴望使用 browserHistory。 像这样 ?_k=ckuvup 没用的在 URL 中是什么？当一个 history 通过应用程序的 push 或 replace 跳转时，它可以在新的 location 中存储 “location state” 而不显示在 URL 中，这就像是在一个 HTML 中 post 的表单数据。 在 DOM API 中，这些 hash history 通过 window.location.hash = newHash 很简单地被用于跳转，且不用存储它们的location state。但我们想全部的 history 都能够使用location state，因此我们要为每一个 location 创建一个唯一的 key，并把它们的状态存储在 session storage 中。当访客点击“后退”和“前进”时，我们就会有一个机制去恢复这些 location state。 createMemoryHistoryMemory history不会在地址栏被操作或读取。这就解释了我们是如何实现服务器渲染的。同时它也非常适合测试和其他的渲染环境（像 React Native ）。 和另外两种history的一点不同是你必须创建它，这种方式便于测试。 1const history = createMemoryHistory(location) 实现示例 12345678910111213141516171819import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; browserHistory, Router, Route, IndexRoute &#125; from &apos;react-router&apos;import App from &apos;../components/App&apos;import Home from &apos;../components/Home&apos;import About from &apos;../components/About&apos;import Features from &apos;../components/Features&apos;render( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&apos;/&apos; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&apos;about&apos; component=&#123;About&#125; /&gt; &lt;Route path=&apos;features&apos; component=&#123;Features&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&apos;app&apos;)) vue-routerHTML5 History 模式vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 1234const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;) 当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！ 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 后端配置例子Apache12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; nginx123location / &#123; try_files $uri $uri/ /index.html;&#125; 原生 Node.js12345678910111213141516171819const http = require(&apos;http&apos;)const fs = require(&apos;fs&apos;)const httpPort = 80http.createServer((req, res) =&gt; &#123; fs.readFile(&apos;index.htm&apos;, &apos;utf-8&apos;, (err, content) =&gt; &#123; if (err) &#123; console.log(&apos;We cannot open &apos;index.htm&apos; file.&apos;) &#125; res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos; &#125;) res.end(content) &#125;)&#125;).listen(httpPort, () =&gt; &#123; console.log(&apos;Server listening on: http://localhost:%s&apos;, httpPort)&#125;) 基于 Node.js 的 Express1对于 Node.js/Express，请考虑使用 connect-history-api-fallback 中间件。 警告给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 123456const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;*&apos;, component: NotFoundComponent &#125; ]&#125;) 或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 Vue 服务端渲染文档。","categories":[],"tags":[]}]}