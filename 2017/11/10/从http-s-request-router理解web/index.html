<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>从http(s) request router理解web | Microbot Team | MT-ryansuen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content>
    <meta name="description" content="如何定义路由（router）电讯网络设备路由器（router）路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。 h">
<meta property="og:type" content="article">
<meta property="og:title" content="从http(s) request router理解web">
<meta property="og:url" content="https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/index.html">
<meta property="og:site_name" content="Microbot Team">
<meta property="og:description" content="如何定义路由（router）电讯网络设备路由器（router）路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。 h">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-03-05T14:45:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从http(s) request router理解web">
<meta name="twitter:description" content="如何定义路由（router）电讯网络设备路由器（router）路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。 h">
    
        <link rel="alternate" type="application/atom+xml" title="Microbot Team" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Ryan Suen</h5>
          <a href="mailto:634206017@qq.com" title="634206017@qq.com" class="mail">634206017@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/yscoder" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/ysweb" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom">
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">从http(s) request router理解web</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">从http(s) request router理解web</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-11-10T05:45:04.000Z" itemprop="datePublished" class="page-time">
  2017-11-10
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何定义路由（router）"><span class="post-toc-number">1.</span> <span class="post-toc-text">如何定义路由（router）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#电讯网络设备路由器（router）"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">电讯网络设备路由器（router）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#http-s-request-router（应用层）"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">http(s) request router（应用层）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#URI-vs-URL"><span class="post-toc-number">2.</span> <span class="post-toc-text">URI vs URL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#网址-链接"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">网址/链接</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#uri-example"><span class="post-toc-number">3.</span> <span class="post-toc-text">uri example</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#URI格式"><span class="post-toc-number">4.</span> <span class="post-toc-text">URI格式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#格式"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">格式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#案例"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">案例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态网站"><span class="post-toc-number">5.</span> <span class="post-toc-text">静态网站</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#静态网页的网址形式通常为："><span class="post-toc-number">5.2.</span> <span class="post-toc-text">静态网页的网址形式通常为：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态网页的特点"><span class="post-toc-number">6.</span> <span class="post-toc-text">静态网页的特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态网站"><span class="post-toc-number">7.</span> <span class="post-toc-text">动态网站</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义-1"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#动态网站的特点"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">动态网站的特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#简单的后端路由代码"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">简单的后端路由代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在线nodejs代理代码"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">在线nodejs代理代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件片段标识符-hash"><span class="post-toc-number">8.</span> <span class="post-toc-text">#文件片段标识符(hash)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ajax的出现可以异步无刷新改变页面内容"><span class="post-toc-number">9.</span> <span class="post-toc-text">ajax的出现可以异步无刷新改变页面内容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#history"><span class="post-toc-number">10.</span> <span class="post-toc-text">history</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#history-HTML5-api"><span class="post-toc-number">11.</span> <span class="post-toc-text">history HTML5 api</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pushState-方法"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">pushState() 方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pushState-方法的例子"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">pushState() 方法的例子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#replaceState-方法"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">replaceState() 方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#replaceState-方法示例"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">replaceState() 方法示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#window-onpopstate"><span class="post-toc-number">12.</span> <span class="post-toc-text">window.onpopstate</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#popstate事件示例"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">popstate事件示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#history-HTML5-api-实际应用"><span class="post-toc-number">13.</span> <span class="post-toc-text">history HTML5 api 实际应用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将首次打开的网页返回到我们预期的网页"><span class="post-toc-number">14.</span> <span class="post-toc-text">将首次打开的网页返回到我们预期的网页</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#当用户点击返回的时候作一些挽留操作"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">当用户点击返回的时候作一些挽留操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pajx-pushState-ajax-开始接近前端路由了"><span class="post-toc-number">15.</span> <span class="post-toc-text">pajx(pushState + ajax) 开始接近前端路由了</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#优点："><span class="post-toc-number">15.1.</span> <span class="post-toc-text">优点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缺点："><span class="post-toc-number">15.2.</span> <span class="post-toc-text">缺点：</span></a></li></ol></li></ol><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#https-github-com-welefen-pjax"><span class="post-toc-number"></span> <span class="post-toc-text">https://github.com/welefen/pjax</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前端路由"><span class="post-toc-number"></span> <span class="post-toc-text">前端路由</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是前端路由"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是前端路由</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前端路由的存在合理性"><span class="post-toc-number">2.</span> <span class="post-toc-text">前端路由的存在合理性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前端路由实现方式"><span class="post-toc-number">3.</span> <span class="post-toc-text">前端路由实现方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何实现更新url并且页面不刷新"><span class="post-toc-number">4.</span> <span class="post-toc-text">如何实现更新url并且页面不刷新</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何跟踪url的变化："><span class="post-toc-number">5.</span> <span class="post-toc-text">如何跟踪url的变化：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#低版本不支持hashchange"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">低版本不支持hashchange</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#低版本不支持hisotry-HTML5-api"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">低版本不支持hisotry HTML5 api</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#https-github-com-browserstate-history-js"><span class="post-toc-number"></span> <span class="post-toc-text">https://github.com/browserstate/history.js/</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react-router"><span class="post-toc-number">1.</span> <span class="post-toc-text">react-router</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Histories"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Histories</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#browserHistory"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">browserHistory</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#服务器配置"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">服务器配置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#IE8-IE9-支持情况"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">IE8, IE9 支持情况</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#hashHistory"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">hashHistory</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#我应该使用-createHashHistory吗？"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">我应该使用 createHashHistory吗？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#像这样-k-ckuvup-没用的在-URL-中是什么？"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">像这样 ?_k=ckuvup 没用的在 URL 中是什么？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#createMemoryHistory"><span class="post-toc-number">1.1.7.</span> <span class="post-toc-text">createMemoryHistory</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue-router"><span class="post-toc-number">2.</span> <span class="post-toc-text">vue-router</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTML5-History-模式"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">HTML5 History 模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#后端配置例子"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">后端配置例子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Apache"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">Apache</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nginx"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">nginx</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#原生-Node-js"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">原生 Node.js</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#基于-Node-js-的-Express"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">基于 Node.js 的 Express</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#警告"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">警告</span></a></li></ol></li></ol>
        </li></nav>
    </aside>


<article id="post-从http-s-request-router理解web" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">从http(s) request router理解web</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-11-10 13:45:04" datetime="2017-11-10T05:45:04.000Z" itemprop="datePublished">2017-11-10</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="如何定义路由（router）"><a href="#如何定义路由（router）" class="headerlink" title="如何定义路由（router）"></a>如何定义路由（router）</h3><h4 id="电讯网络设备路由器（router）"><a href="#电讯网络设备路由器（router）" class="headerlink" title="电讯网络设备路由器（router）"></a>电讯网络设备路由器（router）</h4><p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p>
<h4 id="http-s-request-router（应用层）"><a href="#http-s-request-router（应用层）" class="headerlink" title="http(s) request router（应用层）"></a>http(s) request router（应用层）</h4><hr>
<h3 id="URI-vs-URL"><a href="#URI-vs-URL" class="headerlink" title="URI vs URL"></a>URI vs URL</h3><h4 id="网址-链接"><a href="#网址-链接" class="headerlink" title="网址/链接"></a>网址/链接</h4><p>URI(Uniform Resource Identifier/统一资源标识符)，URI用字符串标识某一互关网资源。支持30多种协议方案（http,https,ftp,file,mailto 等等 ）。</p>
<p>URL(Uniform Resource Locator/统一资源定位符)，URL标识资源的地点。</p>
<p>URL是URI的子集。</p>
<h3 id="uri-example"><a href="#uri-example" class="headerlink" title="uri example"></a>uri example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ftp://linghit.com/shunli/lunar.json</span><br><span class="line">http://zxcs.linghit.com/indexpage/index.html</span><br><span class="line">mailto:sunyi@linghit.com</span><br><span class="line">tel:+1-388-888-8888</span><br><span class="line">telnet://192.168.1.123</span><br><span class="line">https://www.eather.com/get?code=1001</span><br><span class="line"></span><br><span class="line">//绝对URI</span><br><span class="line">https://zxcs.linghit.com/query（cgi）</span><br><span class="line"></span><br><span class="line">//绝对URL</span><br><span class="line">https://zxcs.linghit.com/forecast.images/banner.png</span><br><span class="line"></span><br><span class="line">//相对URI</span><br><span class="line">location.href = &apos;/api/v2/order/query&apos;</span><br></pre></td></tr></table></figure>
<h3 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>协议名://用户名:密码@服务器地址:端口/带层次的文件路径?查询字符串#文件片段标识符</p>
<p>如果类比vue-router,react-router的路由配置，带层次的文件路径可以翻译成嵌套关系:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">React.render((</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;messages/:id&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的配置，这个应用知道如何渲染下面四个 URL：</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">App</td>
</tr>
<tr>
<td style="text-align:center">/about</td>
<td style="text-align:center">App -&gt; About</td>
</tr>
<tr>
<td style="text-align:center">/inbox</td>
<td style="text-align:center">App -&gt; Inbox</td>
</tr>
<tr>
<td style="text-align:center">/inbox/messages/:id</td>
<td style="text-align:center">App -&gt; Inbox -&gt; Message</td>
</tr>
</tbody>
</table>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><a href="https://root:123456@www.zxcs.linghit.com:80/dir1/dir2/index.html?querya=1&amp;queryb=2#name" target="_blank" rel="noopener">https://root:123456@www.zxcs.linghit.com:80/dir1/dir2/index.html?querya=1&amp;queryb=2#name</a></p>
<p>登录认证信息可选，端口号可先，无就用默认。</p>
<hr>
<h3 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在网站设计中，纯粹HTML格式的网页通常被称为“静态网页”，早期的网站一般都是由静态网页制作的。</p>
<h4 id="静态网页的网址形式通常为："><a href="#静态网页的网址形式通常为：" class="headerlink" title="静态网页的网址形式通常为："></a>静态网页的网址形式通常为：</h4><p>也就是以.htm、.html、.shtml、.xml等为后后缀的。在HTML格式的网页上，也可以出现各种动态的效果，如.GIF格式的动画、FLASH、滚动字母等，这些“动态效果”只是视觉上的。</p>
<h3 id="静态网页的特点"><a href="#静态网页的特点" class="headerlink" title="静态网页的特点"></a>静态网页的特点</h3><ul>
<li>静态网页每个网页都有一个固定的URL，且网页URL以.htm、.html、.shtml等常见形式为后缀，而不含有“？”；</li>
<li>网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；</li>
<li>静态网页的内容相对稳定，因此容易被搜索引擎检索；</li>
<li>静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；</li>
<li>静态网页的交互性较差，在功能方面有较大的限制。</li>
</ul>
<p>demo: </p>
<ul>
<li><a href="https://microbotteam.github.io" target="_blank" rel="noopener">https://microbotteam.github.io(/index.html)</a></li>
<li><a href="http://demo.static.web.com" target="_blank" rel="noopener">http://demo.static.web.com(/index.html)</a></li>
</ul>
<hr>
<h3 id="动态网站"><a href="#动态网站" class="headerlink" title="动态网站"></a>动态网站</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>动态网站并不是指具有动画功能的网站，而是指网站内容可根据不同情况动态变更的网站，一般情况下动态网站通过数据库进行架构。 动态网站除了要设计网页外，还要通过数据库和编程序来使网站具有更多自动的和高级的功能。动态网站体现在网页一般是以asp，jsp，php，aspx等结束，而静态网页一般是HTML（标准通用标记语言的子集）结尾，动态网站服务器空间配置要比静态的网页要求高，费用也相应的高，不过动态网页利于网站内容的更新，适合企业建站。动态是相对于静态网站而言。</p>
<h4 id="动态网站的特点"><a href="#动态网站的特点" class="headerlink" title="动态网站的特点"></a>动态网站的特点</h4><ul>
<li>动态网站可以实现交互功能，如用户注册、信息发布、产品展示、订单管理等等；</li>
<li>动态网页并不是独立存在于服务器的网页文件，而是浏览器发出请求时才反馈网页；</li>
<li>动态网页中包含有服务器端脚本，所以页面文件名常以asp、jsp、php等为后缀。但也可以使用URL静态化技术，使网页后缀显示为HTML。所以不能以页面文件的后缀作为判断网站的动态和静态的唯一标准。</li>
<li>动态网页由于需要数据库处理，所以动态网站的访问速度大大减慢；</li>
<li>动态网页由于存在特殊代码，所以相比较静态网页，其对搜索引擎的友好程度相对要弱一些。<br>但随着计算机性能的提升以及网络带宽的提升，最后两条已经基本得到解决。</li>
</ul>
<h4 id="简单的后端路由代码"><a href="#简单的后端路由代码" class="headerlink" title="简单的后端路由代码"></a>简单的后端路由代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const httpPort = 3000</span><br><span class="line"></span><br><span class="line">function simpleRouter(ctx, url) &#123;</span><br><span class="line">    let res;</span><br><span class="line">    if (/query/i.test(url)) &#123;</span><br><span class="line">        res = `</span><br><span class="line">        &lt;h1&gt;query&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;$&#123;url&#125;&lt;/h2&gt;</span><br><span class="line">        `;</span><br><span class="line">    &#125; else if (/date/i.test(url)) &#123;</span><br><span class="line">        res = `</span><br><span class="line">        &lt;h1&gt;date&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;$&#123;new Date().toString()&#125;&lt;/h2&gt;</span><br><span class="line">        `;</span><br><span class="line">    &#125; else if (&apos;/test.html&apos; === url) &#123;</span><br><span class="line">        res = fs.readFileSync(&apos;test.html&apos;, &apos;utf-8&apos;, (err, content) =&gt; &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = &apos;404&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    let url = req.url,</span><br><span class="line">        response;</span><br><span class="line"></span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    response = simpleRouter(res, url);</span><br><span class="line">    res.end(response);</span><br><span class="line">&#125;).listen(httpPort, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;Server listening on: http://localhost:%s&apos;, httpPort)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在线nodejs代理代码"><a href="#在线nodejs代理代码" class="headerlink" title="在线nodejs代理代码"></a>在线nodejs代理代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const serve = require(&apos;koa-static-server&apos;);</span><br><span class="line">const router = require(&apos;koa-router&apos;)();</span><br><span class="line">const app = new Koa();</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const koaBody = require(&apos;koa-body&apos;);</span><br><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line">const rp = require(&apos;request-promise&apos;);</span><br><span class="line"></span><br><span class="line">app.use( router.routes() ).use( router.allowedMethods() );</span><br><span class="line"></span><br><span class="line">router.all(</span><br><span class="line">    &apos;*&apos;,</span><br><span class="line">    koaBody(),</span><br><span class="line">    async function(ctx, next) &#123;</span><br><span class="line">        let url = ctx.request.url,</span><br><span class="line">            proxy = &apos;http://sandbox.zxcs.linghit.com&apos;;</span><br><span class="line">            method = ctx.request.method,</span><br><span class="line">            referer = ctx.request.header.referer,</span><br><span class="line">            api = `$&#123;proxy&#125;$&#123;url&#125;`;</span><br><span class="line">        if( /api/i.test(url) ) &#123;</span><br><span class="line">            </span><br><span class="line">            if( &apos;GET&apos; === method ) &#123;</span><br><span class="line">                let result =   await new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">                    request.get(api, (err, res, body) =&gt; &#123;</span><br><span class="line">                        if( err ) &#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            resolve(body);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; );</span><br><span class="line">                ctx.body = result;</span><br><span class="line">            &#125; else if(&apos;POST&apos; === method) &#123;</span><br><span class="line">                let result =   await new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">                    request.post(&#123;</span><br><span class="line">                        url: api,</span><br><span class="line">                        form: ctx.request.body                        </span><br><span class="line">                    &#125;, (err, res, body) =&gt; &#123;</span><br><span class="line">                        if( err ) &#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            resolve(body);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; );</span><br><span class="line">                ctx.body = result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if( /payment/i.test(url) ) &#123;</span><br><span class="line">                let result =   await new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">                    request.get(api, (err, res, body) =&gt; &#123;</span><br><span class="line">                        if( err ) &#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            resolve(body);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; );</span><br><span class="line">                if(/page-result/img.test(result) ) &#123;</span><br><span class="line">                    let new_referer = referer.substring(0, (referer.lastIndexOf(&apos;/&apos;) + 1 ) ),</span><br><span class="line">                        query = url.substring( url.indexOf(&apos;?&apos;) ),</span><br><span class="line">                        result = /BZJP/i.test(url) ? &apos;resultQt.html&apos; : result.html;</span><br><span class="line">                    ctx.redirect(`$&#123;new_referer&#125;$&#123;result&#125;$&#123;query&#125;`);                   </span><br><span class="line">                &#125;</span><br><span class="line">                ctx.body = result;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                await next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">    serve(&#123;</span><br><span class="line">        rootDir: path.join(__dirname, &apos;../public/&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">let port = 80;</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;&apos;);</span><br><span class="line">    console.log(&apos;--------------------------------&apos;);</span><br><span class="line">    console.log(&apos;&apos;);</span><br><span class="line">    console.log(`proxy start on prot $&#123;port&#125;`);</span><br><span class="line">    console.log(&apos;&apos;);</span><br><span class="line">    console.log(&apos;--------------------------------&apos;);</span><br><span class="line">    console.log(&apos;&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件片段标识符-hash"><a href="#文件片段标识符-hash" class="headerlink" title="#文件片段标识符(hash)"></a>#文件片段标识符(hash)</h3><p>了解http协议就会知道，url的组成部分有很多，譬如协议、主机名、资源路径、查询字段等等，其中包含一个称之为片段的部分，以“#”为标识。</p>
<p>例如： <a href="http://www.gmail.com/text/#123，123便是url中的hash部分。" target="_blank" rel="noopener">http://www.gmail.com/text/#123，123便是url中的hash部分。</a></p>
<p>打开控制台，输入 location.hash，你可以得到当前url的hash部分（如果当前url不存在hash则返回空字符串）。接下来，输入 location.hash = ‘123’，会发现浏览器地址栏的url变了，末尾增加了’#123’字段，并且，页面没有被重新刷新。很显然，这很符合我们的要求。</p>
<hr>
<h3 id="ajax的出现可以异步无刷新改变页面内容"><a href="#ajax的出现可以异步无刷新改变页面内容" class="headerlink" title="ajax的出现可以异步无刷新改变页面内容"></a>ajax的出现可以异步无刷新改变页面内容</h3><p>（太熟悉了， 略过）</p>
<hr>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//向前和向后跳转</span><br><span class="line">window.history.forward();</span><br><span class="line">window.history.back();</span><br><span class="line"></span><br><span class="line">//跳转到 history 中指定的一个点</span><br><span class="line">window.history.go(-1);    //back()</span><br><span class="line">window.history.go(1);    //forward()</span><br></pre></td></tr></table></figure>
<h3 id="history-HTML5-api"><a href="#history-HTML5-api" class="headerlink" title="history HTML5 api"></a>history HTML5 api</h3><ul>
<li>history.pushState()//添加历史记录条目</li>
<li>history.replaceState()//修改历史记录条目</li>
<li>window.onpopstate//上面两方法与其配合使用</li>
</ul>
<p>使用 history.pushState() 可以改变referrer，它在用户发送 XMLHttpRequest 请求时在HTTP头部使用，改变state后创建的 XMLHttpRequest 对象的referrer都会被改变。因为referrer是标识 /创建XMLHttpRequest对象时/this 所代表的/window对象中document的/URL。</p>
<h4 id="pushState-方法"><a href="#pushState-方法" class="headerlink" title="pushState() 方法"></a>pushState() 方法</h4><p>pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容：</p>
<ul>
<li><p>状态对象 -</p>
<ul>
<li>状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。</li>
<li>状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.</li>
</ul>
</li>
<li><p>标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。</p>
</li>
<li><p>URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</p>
</li>
</ul>
<p>在某种意义上，调用 pushState() 与 设置 window.location = “#foo” 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点：</p>
<ul>
<li>新的 URL 可以是与当前URL同源的任意URL 。而设置 window.location 仅当你只修改了哈希值时才保持同一个 document。</li>
<li>如果需要，你可以不必改变URL。而设置 window.location = “#foo”;在当前哈希不是 #foo 的情况下， 仅仅是新建了一个新的历史记录项。</li>
<li>你可以为新的历史记录项关联任意数据。而基于哈希值的方式，则必须将所有相关数据编码到一个短字符串里。 </li>
<li>假如 标题 在之后会被浏览器用到，那么这个数据是可以被使用的（哈希则不然）。</li>
</ul>
<p>注意 pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。 </p>
<h4 id="pushState-方法的例子"><a href="#pushState-方法的例子" class="headerlink" title="pushState() 方法的例子"></a>pushState() 方法的例子</h4><p>假设在 <a href="http://mozilla.org/foo.html" target="_blank" rel="noopener">http://mozilla.org/foo.html</a> 中执行了以下 JavaScript 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stateObj = &#123; foo: &quot;bar&quot; &#125;;</span><br><span class="line">history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;);</span><br></pre></td></tr></table></figure>
<p>这将使浏览器地址栏显示为 <a href="http://mozilla.org/bar.html，但并不会导致浏览器加载" target="_blank" rel="noopener">http://mozilla.org/bar.html，但并不会导致浏览器加载</a> bar.html ，甚至不会检查bar.html 是否存在。</p>
<p>假设现在用户又访问了 <a href="http://google.com，然后点击了返回按钮。此时，地址栏将显示" target="_blank" rel="noopener">http://google.com，然后点击了返回按钮。此时，地址栏将显示</a> <a href="http://mozilla.org/bar.html，同时页面会触发" target="_blank" rel="noopener">http://mozilla.org/bar.html，同时页面会触发</a> popstate 事件，事件对象state中包含了 stateObj 的一份拷贝。页面本身与 foo.html 一样，尽管其在 popstate  事件中可能会修改自身的内容。</p>
<p>如果我们再次点击返回按钮，页面URL会变为<a href="http://mozilla.org/foo.html，文档对象document会触发另外一个" target="_blank" rel="noopener">http://mozilla.org/foo.html，文档对象document会触发另外一个</a> popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。</p>
<h4 id="replaceState-方法"><a href="#replaceState-方法" class="headerlink" title="replaceState() 方法"></a>replaceState() 方法</h4><p>history.replaceState() 的使用与 history.pushState() 非常相似，区别在于  replaceState()  是修改了当前的历史记录项而不是新建一个。 注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。</p>
<p>replaceState()的使用场景在于为了响应用户操作，你想要更新状态对象state或者当前历史记录的URL。</p>
<h4 id="replaceState-方法示例"><a href="#replaceState-方法示例" class="headerlink" title="replaceState() 方法示例"></a>replaceState() 方法示例</h4><p>假设 <a href="http://mozilla.org/foo.html" target="_blank" rel="noopener">http://mozilla.org/foo.html</a> 执行了如下JavaScript代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stateObj = &#123; foo: &quot;bar&quot; &#125;;</span><br><span class="line">history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;);</span><br></pre></td></tr></table></figure></p>
<p>然后，假设<a href="http://mozilla.org/bar.html执行了如下" target="_blank" rel="noopener">http://mozilla.org/bar.html执行了如下</a> JavaScript：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.replaceState(stateObj, &quot;page 3&quot;, &quot;bar2.html&quot;);</span><br></pre></td></tr></table></figure>
<p>这将会导致地址栏显示<a href="http://mozilla.org/bar2.html,，但是浏览器并不会去加载bar2.html" target="_blank" rel="noopener">http://mozilla.org/bar2.html,，但是浏览器并不会去加载bar2.html</a> 甚至都不需要检查 bar2.html 是否存在。</p>
<p>假设现在用户重新导向到了<a href="http://www.microsoft.com，然后点击了回退按按钮。这里，地址栏会显示http://mozilla.org/bar2.html。加入用户再次点击回退按钮，地址栏会显示http://mozilla.org/foo.html，完全跳过了abar.html。" target="_blank" rel="noopener">http://www.microsoft.com，然后点击了回退按按钮。这里，地址栏会显示http://mozilla.org/bar2.html。加入用户再次点击回退按钮，地址栏会显示http://mozilla.org/foo.html，完全跳过了abar.html。</a></p>
<h3 id="window-onpopstate"><a href="#window-onpopstate" class="headerlink" title="window.onpopstate"></a>window.onpopstate</h3><p>window.onpopstate是popstate事件在window对象上的事件处理程序.</p>
<p>每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝.</p>
<p>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).</p>
<p>当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会.</p>
<h4 id="popstate事件示例"><a href="#popstate事件示例" class="headerlink" title="popstate事件示例"></a>popstate事件示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = function(event) &#123;</span><br><span class="line">  alert(&quot;location: &quot; + document.location + &quot;, state: &quot; + JSON.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line">//绑定事件处理函数. </span><br><span class="line">history.pushState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;?page=1&quot;);    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1</span><br><span class="line">history.pushState(&#123;page: 2&#125;, &quot;title 2&quot;, &quot;?page=2&quot;);    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2</span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &quot;title 3&quot;, &quot;?page=3&quot;); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3</span><br><span class="line">history.back(); // 弹出 &quot;location: http://example.com/example.html?page=1, state: &#123;&quot;page&quot;:1&#125;&quot;</span><br><span class="line">history.back(); // 弹出 &quot;location: http://example.com/example.html, state: null</span><br><span class="line">history.go(2);  // 弹出 &quot;location: http://example.com/example.html?page=3, state: &#123;&quot;page&quot;:3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="history-HTML5-api-实际应用"><a href="#history-HTML5-api-实际应用" class="headerlink" title="history HTML5 api 实际应用"></a>history HTML5 api 实际应用</h3><h3 id="将首次打开的网页返回到我们预期的网页"><a href="#将首次打开的网页返回到我们预期的网页" class="headerlink" title="将首次打开的网页返回到我们预期的网页"></a>将首次打开的网页返回到我们预期的网页</h3><p>易起问的入口为：yd.linghit.com</p>
<p>易起问的老师页面地址：yd.linghit.com/home/user/index?answer_id=250</p>
<p>这两个链接都可以直接作为外链让用户点击后进入对应的页面，正常情况下以微信为列，进入页面不跳转至其他页面点击手机的返回键，页面会关闭直接返回到进行页面的地方。老板觉得这样不太好，应该点击返回键后调到首页再退出。。。。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// document.referrer 表示当前文档的来源，即当前文档是从那个文档打开的url，</span><br><span class="line">// 抓包发现从微信直接进来的链接来源referrer是null，从网页内部跳转的是正常的，所以通过判断referrer来判断是否从微信直接跳进来进行处理，对于正常页面跳转不做处理</span><br><span class="line">        if(!document.referrer)&#123;</span><br><span class="line">            if( window.history &amp;&amp;　window.history.pushState )&#123;</span><br><span class="line">                // 压入历史记录状态</span><br><span class="line">                </span><br><span class="line">                history.pushState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;&quot;);</span><br><span class="line">               </span><br><span class="line">                // 只有使用pushState和replaceState才能监听popstate后退事件</span><br><span class="line">                </span><br><span class="line">                window.addEventListener(&quot;popstate&quot;, function () &#123;</span><br><span class="line">                   </span><br><span class="line">                    // 后退时把当前的历史状态改为你要跳转的页面，防止多次回退又回来的问题</span><br><span class="line">                    history.replaceState(&#123;page: 1&#125;, &quot;title 1&quot;, &quot;/home/index/index&quot;);</span><br><span class="line">                  </span><br><span class="line">                    // 这里就可以处理自己的事情了</span><br><span class="line">                    location.href = &quot;/home/index/index&quot;;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="当用户点击返回的时候作一些挽留操作"><a href="#当用户点击返回的时候作一些挽留操作" class="headerlink" title="当用户点击返回的时候作一些挽留操作"></a>当用户点击返回的时候作一些挽留操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//popstate自动触发的bug（目前暂时发现在iPhone6可以还原这个bug）</span><br><span class="line">(function() &#123;</span><br><span class="line">	if(window.history.pushState)&#123;</span><br><span class="line">		//初始时如果没有state，先加一个进去，防止popstate不触发</span><br><span class="line">		if(!window.history.state)&#123;</span><br><span class="line">			window.history.pushState(&apos;init&apos;, &apos;&apos;, &apos;&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">		//为当前页面history压入一个state</span><br><span class="line">		window.history.replaceState(&#123;hasState: true&#125;, &apos;&apos;, &apos;&apos;);</span><br><span class="line">		console.log(&apos;push state over&apos;);</span><br><span class="line">		</span><br><span class="line">		window.addEventListener(&apos;load&apos;, function() &#123;     </span><br><span class="line">            setTimeout(function() &#123;    </span><br><span class="line">            </span><br><span class="line">               //监听页面的popstate事件。此事件一般在用户点击浏览器后退或前进按钮时触发。</span><br><span class="line">        		window.addEventListener(&apos;popstate&apos;, function(e) &#123;</span><br><span class="line">        			console.log(&apos;popstate trigger.&apos;);</span><br><span class="line">        			//侦测是用户触发的操作, 处理自定义逻辑，弹窗或其他</span><br><span class="line">        			alert(&apos;浏览器后退！&apos;);</span><br><span class="line">        		&#125;, false);  </span><br><span class="line">        		</span><br><span class="line">            &#125;, 0);   </span><br><span class="line">         &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pajx-pushState-ajax-开始接近前端路由了"><a href="#pajx-pushState-ajax-开始接近前端路由了" class="headerlink" title="pajx(pushState + ajax) 开始接近前端路由了"></a>pajx(pushState + ajax) 开始接近前端路由了</h3><p><a href="http://demo.static.web.com/pjax.html" target="_blank" rel="noopener">http://demo.static.web.com/pjax.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;pjax&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;pjax page!&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">        &lt;ul id=&quot;nav-box&quot;&gt;</span><br><span class="line">            &lt;li data-index=&quot;part1.html&quot; class=&quot;todo&quot; class=&quot;active&quot;&gt;part1&lt;/li&gt;</span><br><span class="line">            &lt;li data-index=&quot;part2.html&quot;&gt;part2&lt;/li&gt;</span><br><span class="line">            &lt;li data-index=&quot;part3.html&quot;&gt;part3&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;section id=&quot;page-containter&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (function() &#123;</span><br><span class="line"></span><br><span class="line">            var setContent = function(content) &#123;</span><br><span class="line">                var $container = document.getElementById(&apos;page-containter&apos;);</span><br><span class="line">                $container.innerHTML = content;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            var makeRequest = function makeRequest(options) &#123;</span><br><span class="line">                httpRequest = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">                if (!httpRequest) &#123;</span><br><span class="line">                    console.error(&apos;Giving up :( Cannot create an XMLHTTP instance&apos;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                httpRequest.onreadystatechange = function() &#123;</span><br><span class="line">                    if (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">                        if (httpRequest.status === 200) &#123;</span><br><span class="line">                            options.cb(httpRequest.responseText);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            console.error(&apos;There was a problem with the request.&apos;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;;</span><br><span class="line">                httpRequest.open(&apos;GET&apos;, options.url || &apos;part1.html&apos;);</span><br><span class="line">                httpRequest.send();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //页面初始化</span><br><span class="line">            var init = function() &#123;</span><br><span class="line">                makeRequest(&#123;</span><br><span class="line">                    url: location.search.replace(&apos;?&apos;, &apos;&apos;) || &apos;part1.html&apos;,</span><br><span class="line">                    cb: function(res) &#123;</span><br><span class="line">                        setContent(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            init();</span><br><span class="line"></span><br><span class="line">            //导航事件</span><br><span class="line">            (function() &#123;</span><br><span class="line">                var $box = document.getElementById(&apos;nav-box&apos;);</span><br><span class="line">                $box.addEventListener(&apos;click&apos;, function clickCb(e) &#123;</span><br><span class="line">                    var urlIndex = e.target.getAttribute(&apos;data-index&apos;);</span><br><span class="line">                    makeRequest(&#123;</span><br><span class="line">                        url: urlIndex,</span><br><span class="line">                        cb: function(res) &#123;</span><br><span class="line">                            window.history.pushState(&#123;</span><br><span class="line">                                page: urlIndex</span><br><span class="line">                            &#125;, &apos;&apos;, &apos;?&apos; + urlIndex);</span><br><span class="line">                            setContent(res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;, false);</span><br><span class="line">            &#125;)();</span><br><span class="line"></span><br><span class="line">            if (window.history.pushState) &#123;</span><br><span class="line"></span><br><span class="line">                //初始时如果没有state，先加一个进去，防止popstate不触发</span><br><span class="line">                if (!window.history.state) &#123;</span><br><span class="line">                    window.history.pushState(&#123;</span><br><span class="line">                        page: &apos;part1.html&apos;</span><br><span class="line">                    &#125;, &apos;&apos;, &apos;?part1.html&apos;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                window.addEventListener(&apos;load&apos;, function() &#123;</span><br><span class="line">                    setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">                        //监听页面的popstate事件。此事件一般在用户点击浏览器后退或前进按钮时触发。</span><br><span class="line">                        window.addEventListener(&apos;popstate&apos;, function(e) &#123;</span><br><span class="line">                            e.state &amp;&amp; e.state.page &amp;&amp; makeRequest(&#123;</span><br><span class="line">                                url: e.state.page,</span><br><span class="line">                                cb: function(res) &#123;</span><br><span class="line">                                    setContent(res);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;, false);</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>减轻服务端压力</li>
</ul>
<p>按需请求，每次只需加载页面的部分内容，而不用重复加载一些公共的资源文件和不变的页面结构，大大减小了数据请求量，以减轻对服务器的带宽和性能压力，还大大提升了页面的加载速度。</p>
<ul>
<li>优化页面跳转体验</li>
</ul>
<p>常规页面跳转需要重新加载画面上的内容，会有明显的闪烁，而且往往和跳转前的页面没有连贯性，用户体验不是很好。如果再遇上页面比较庞大、网速又不是很好的情况，用户体验就更加雪上加霜了。使用pjax后，由于只刷新部分页面，切换效果更加流畅，而且可以定制过度动画，在等待页面加载的时候体验就比较舒服了。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><p>不支持一些低版本的浏览器(如IE系列)</p>
<p>  pjax使用了pushState来改变地址栏的url，这是html5中history的新特性，在某些旧版浏览器中可能不支持。不过pjax会进行判断，功能不适用的时候会执行默认的页面跳转操作。</p>
</li>
<li><p>使服务端处理变得复杂</p>
<p>  要做到普通请求返回完整页面，而pjax请求只返回部分页面，服务端就需要做一些特殊处理，当然这对于设计良好的后端框架来说，添加一些统一处理还是比较容易的，自然也没太大问题。另外，即使后台不做处理，设置pjax的fragment参数来达到同样的效果。</p>
</li>
</ul>
<p>综合来看，pajx的优点很强势，缺点也几乎可以忽略，还是非常值得推荐的，尤其是类似博客这种大部分情况下只有主体内容变化的网站。关键它使用简单、学习成本小，即时全站只有极个别页面能用得到，尝试下没什么损失。pjax的github主页介绍的已经很详细了，想了解更多可以看下源码。</p>
<h2 id="https-github-com-welefen-pjax"><a href="#https-github-com-welefen-pjax" class="headerlink" title="https://github.com/welefen/pjax"></a><a href="https://github.com/welefen/pjax" target="_blank" rel="noopener">https://github.com/welefen/pjax</a></h2><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><h3 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h3><p>前端路由，拥有这样一种能力：客户端浏览器可以不依赖服务端，根据不同的URL渲染不同的视图页面。</p>
<h3 id="前端路由的存在合理性"><a href="#前端路由的存在合理性" class="headerlink" title="前端路由的存在合理性"></a>前端路由的存在合理性</h3><p>在Ajax之剑还未亮出，前端仍处于襁褓之中的时候，路由的工作交给了后端。在进行页面切换的时候，浏览器发送不同的url请求；服务器接收到浏览器的请求时，通过解析不同的url去拼接需要的html或者模板，然后将结果返回给浏览器端进行渲染。</p>
<p>服务器端路由也是不落俗套的有利亦有弊。它的好处是安全性更高，更严格得控制页面的展现。这在某些场景中是很有用的，譬如下单支付流程，每一步只有在上一步成功执行之后才能抵达。这在服务器端可以为每一步流程添加验证机制，只有验证通过才返回正确的页面。那么前端路由不能实现每一步的验证？自然不是，姑且相信你的代码可以写的很严谨，保证正常情况下流程不会错，但是另一个不得不面对的事实是：前端是毫无安全性可言的。用户可以肆意修改代码来进入不同的流程，你可能会为此添加不少的处理逻辑。相较之下，当然是后端控制页面的进入权限更为安全和简便。</p>
<p>另一方面，后端路由无疑增加了服务器端的负荷，并且需要reload页面，用户体验其实不佳。</p>
<p>这样，前端路由就有用武之地了。首先，它的出现无疑减轻了服务器端的压力。特别是对于一个比较复杂的应用来讲，或者更确切的说，对于拥有一个复杂路由系统的应用来说，服务器端需要为每一个不同的url执行一段处理逻辑在高并发的情况下实在有点不堪重负；其次，页面的切换可以不需要刷新整个页面了，没有网络延迟，没有闪烁刷新，提升了用户体验。</p>
<h3 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h3><ul>
<li>在页面不刷新的前提下实现url变化</li>
<li>捕捉到url的变化，以便执行页面替换逻辑</li>
</ul>
<h3 id="如何实现更新url并且页面不刷新"><a href="#如何实现更新url并且页面不刷新" class="headerlink" title="如何实现更新url并且页面不刷新"></a>如何实现更新url并且页面不刷新</h3><ol>
<li>利用url中的hash字段；</li>
<li>使用html5提供的history API。</li>
</ol>
<h3 id="如何跟踪url的变化："><a href="#如何跟踪url的变化：" class="headerlink" title="如何跟踪url的变化："></a>如何跟踪url的变化：</h3><ol>
<li>hash + window.onhashchange</li>
<li>history HTML5 api + window.onpopState</li>
</ol>
<h4 id="低版本不支持hashchange"><a href="#低版本不支持hashchange" class="headerlink" title="低版本不支持hashchange"></a>低版本不支持hashchange</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(function(window) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果浏览器原生支持该事件,则退出  </span><br><span class="line">if ( &quot;onhashchange&quot; in window.document.body ) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">  var location = window.location,</span><br><span class="line">    oldURL = location.href,</span><br><span class="line">    oldHash = location.hash;</span><br><span class="line"></span><br><span class="line">  // 每隔100ms检测一下location.hash是否发生变化</span><br><span class="line">  setInterval(function() &#123;</span><br><span class="line">    var newURL = location.href,</span><br><span class="line">      newHash = location.hash;</span><br><span class="line"></span><br><span class="line">    // 如果hash发生了变化,且绑定了处理函数...</span><br><span class="line">    if ( newHash != oldHash &amp;&amp; typeof window.onhashchange === &quot;function&quot; ) &#123;</span><br><span class="line">      // execute the handler</span><br><span class="line">      window.onhashchange(&#123;</span><br><span class="line">        type: &quot;hashchange&quot;,</span><br><span class="line">        oldURL: oldURL,</span><br><span class="line">        newURL: newURL</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      oldURL = newURL;</span><br><span class="line">      oldHash = newHash;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 100);</span><br><span class="line"></span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>
<h4 id="低版本不支持hisotry-HTML5-api"><a href="#低版本不支持hisotry-HTML5-api" class="headerlink" title="低版本不支持hisotry HTML5 api"></a>低版本不支持hisotry HTML5 api</h4><h2 id="https-github-com-browserstate-history-js"><a href="#https-github-com-browserstate-history-js" class="headerlink" title="https://github.com/browserstate/history.js/"></a><a href="https://github.com/browserstate/history.js/" target="_blank" rel="noopener">https://github.com/browserstate/history.js/</a></h2><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><h4 id="Histories"><a href="#Histories" class="headerlink" title="Histories"></a>Histories</h4><p>React Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。</p>
<p>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<ul>
<li>browserHistory</li>
<li>hashHistory</li>
<li>createMemoryHistory<br>你可以从 React Router 中引入它们：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// JavaScript 模块导入（译者注：ES6 形式）</span><br><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</span><br></pre></td></tr></table></figure>
<p>然后将它们传递给<router>:</router></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="browserHistory"><a href="#browserHistory" class="headerlink" title="browserHistory"></a>browserHistory</h5><p>Browser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。</p>
<h5 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h5><p>服务器需要做好处理 URL 的准备。处理应用启动最初的 / 这样的请求应该没问题，但当用户来回跳转并在 /accounts/123 刷新时，服务器就会收到来自 /accounts/123 的请求，这时你需要处理这个 URL 并在响应中包含 JavaScript 应用代码。</p>
<p>一个 express 的应用可能看起来像这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const port = process.env.PORT || 8080</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 通常用于加载静态资源</span><br><span class="line">app.use(express.static(__dirname + &apos;/public&apos;))</span><br><span class="line"></span><br><span class="line">// 在你应用 JavaScript 文件中包含了一个 script 标签</span><br><span class="line">// 的 index.html 中处理任何一个 route</span><br><span class="line">app.get(&apos;*&apos;, function (request, response)&#123;</span><br><span class="line">  response.sendFile(path.resolve(__dirname, &apos;public&apos;, &apos;index.html&apos;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port)</span><br><span class="line">console.log(&quot;server started on port &quot; + port)</span><br></pre></td></tr></table></figure>
<p>如果你的服务器是 nginx，请使用 try_files 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  location / &#123;</span><br><span class="line">    try_files $uri /index.html</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在服务器上找不到其他文件时，这可以让 nginx 服务器提供静态文件服务并指向index.html 文件。</p>
<p>对于Apache服务器也有类似的方式，创建一个.htaccess文件在你的文件根目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RewriteBase /</span><br><span class="line">RewriteRule ^index\.html$ - [L]</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule . /index.html [L]</span><br></pre></td></tr></table></figure>
<h5 id="IE8-IE9-支持情况"><a href="#IE8-IE9-支持情况" class="headerlink" title="IE8, IE9 支持情况"></a>IE8, IE9 支持情况</h5><p>如果我们能使用浏览器自带的 window.history API，那么我们的特性就可以被浏览器所检测到。如果不能，那么任何调用跳转的应用就会导致 全页面刷新，它允许在构建应用和更新浏览器时会有一个更好的用户体验，但仍然支持的是旧版的。</p>
<p>你可能会想为什么我们不后退到 hash history，问题是这些 URL 是不确定的。如果一个访客在 hash history 和 browser history 上共享一个 URL，然后他们也共享同一个后退功能，最后我们会以产生笛卡尔积数量级的、无限多的 URL 而崩溃。</p>
<h5 id="hashHistory"><a href="#hashHistory" class="headerlink" title="hashHistory"></a>hashHistory</h5><p>Hash history 使用 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由。</p>
<h5 id="我应该使用-createHashHistory吗？"><a href="#我应该使用-createHashHistory吗？" class="headerlink" title="我应该使用 createHashHistory吗？"></a>我应该使用 createHashHistory吗？</h5><p>Hash history不需要服务器任何配置就可以运行，如果你刚刚入门，那就使用它吧。但是我们不推荐在实际线上环境中用到它，因为每一个 web 应用都应该渴望使用 browserHistory。</p>
<h5 id="像这样-k-ckuvup-没用的在-URL-中是什么？"><a href="#像这样-k-ckuvup-没用的在-URL-中是什么？" class="headerlink" title="像这样 ?_k=ckuvup 没用的在 URL 中是什么？"></a>像这样 ?_k=ckuvup 没用的在 URL 中是什么？</h5><p>当一个 history 通过应用程序的 push 或 replace 跳转时，它可以在新的 location 中存储 “location state” 而不显示在 URL 中，这就像是在一个 HTML 中 post 的表单数据。</p>
<p>在 DOM API 中，这些 hash history 通过 window.location.hash = newHash 很简单地被用于跳转，且不用存储它们的location state。但我们想全部的 history 都能够使用location state，因此我们要为每一个 location 创建一个唯一的 key，并把它们的状态存储在 session storage 中。当访客点击“后退”和“前进”时，我们就会有一个机制去恢复这些 location state。</p>
<h5 id="createMemoryHistory"><a href="#createMemoryHistory" class="headerlink" title="createMemoryHistory"></a>createMemoryHistory</h5><p>Memory history不会在地址栏被操作或读取。这就解释了我们是如何实现服务器渲染的。同时它也非常适合测试和其他的渲染环境（像 React Native ）。</p>
<p>和另外两种history的一点不同是你必须创建它，这种方式便于测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const history = createMemoryHistory(location)</span><br></pre></td></tr></table></figure>
<p>实现示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import &#123; render &#125; from &apos;react-dom&apos;</span><br><span class="line">import &#123; browserHistory, Router, Route, IndexRoute &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">import App from &apos;../components/App&apos;</span><br><span class="line">import Home from &apos;../components/Home&apos;</span><br><span class="line">import About from &apos;../components/About&apos;</span><br><span class="line">import Features from &apos;../components/Features&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=&apos;/&apos; component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;IndexRoute component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route path=&apos;about&apos; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=&apos;features&apos; component=&#123;Features&#125; /&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h4><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p>
<p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id，也好看！" target="_blank" rel="noopener">http://yoursite.com/user/id，也好看！</a></p>
<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p>
<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
<h4 id="后端配置例子"><a href="#后端配置例子" class="headerlink" title="后端配置例子"></a>后端配置例子</h4><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">  RewriteEngine On</span><br><span class="line">  RewriteBase /</span><br><span class="line">  RewriteRule ^index\.html$ - [L]</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">  RewriteRule . /index.html [L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<h5 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  try_files $uri $uri/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原生-Node-js"><a href="#原生-Node-js" class="headerlink" title="原生 Node.js"></a>原生 Node.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const httpPort = 80</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  fs.readFile(&apos;index.htm&apos;, &apos;utf-8&apos;, (err, content) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      console.log(&apos;We cannot open &apos;index.htm&apos; file.&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res.end(content)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(httpPort, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server listening on: http://localhost:%s&apos;, httpPort)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="基于-Node-js-的-Express"><a href="#基于-Node-js-的-Express" class="headerlink" title="基于 Node.js 的 Express"></a>基于 Node.js 的 Express</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于 Node.js/Express，请考虑使用 connect-history-api-fallback 中间件。</span><br></pre></td></tr></table></figure>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;*&apos;, component: NotFoundComponent &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 Vue 服务端渲染文档。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-03-05T14:45:54.000Z" itemprop="dateUpdated">2019-03-05 22:45:54</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/11/10/从http-s-request-router理解web/" target="_blank" rel="external">https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/</a>
        
    </div>
    
    <footer>
        <a href="https://ryansuen.github.io">
            <img src="/img/avatar.jpg" alt="Ryan Suen">
            Ryan Suen
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&title=《从http(s) request router理解web》 — Microbot Team&pic=https://ryansuen.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&title=《从http(s) request router理解web》 — Microbot Team&source=description" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《从http(s) request router理解web》 — Microbot Team&url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&via=https://ryansuen.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/11/20/深入理解javascript事件/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">深入理解javascript事件</h4>
      </a>
    </div>
  

  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Ryan Suen &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&title=《从http(s) request router理解web》 — Microbot Team&pic=https://ryansuen.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&title=《从http(s) request router理解web》 — Microbot Team&source=description" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《从http(s) request router理解web》 — Microbot Team&url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/&via=https://ryansuen.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://ryansuen.github.io/2017/11/10/从http-s-request-router理解web/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtklEQVR42u3awWojMRAEUP//T2dhyWEhjF3VPVo78HQywYzmyaBWSv14xOPr7/j5l3/Hz29efSd/8vNv3jbw8PDwRq9+NZ5PeWJpZgt3+YZ4eHh4x3jPXyuZMn/m84XLlzuaFw8PD++tvKRItBt9PgseHh7e7+UlQUMSKOTbPR4eHt5n8mZBwHP8psy8IWvBw8PDi3ltFPsJnw/e7+Hh4eEtbtXzIpFHt20kMXvP7yfg4eHhHeDtL7fyo3C+rc8OysV/DHh4eHg38doJ6g06CI7zC7aitODh4eH9R969u2sbHM+uwS6P1Hh4eHg38ZKAINmCN2Fr3qTVFg88PDy8c7y24Wlzkb8JbfOWr6JLCw8PD6/k7RnJZHmZaUPe+qfCw8PDu4mXtwVsXnF2QG/LwIusBQ8PD2/Nmx2Lk8PxjL0pPFEYgYeHh7fmzf5nn8UK7YF4E+OuIgk8PDy8YIecBbibpqhNlFy8Mx4eHt4x3okdtS0S+RIUS4mHh4d3gJeHp+01/wzZLlwUT+Dh4eHdypvB8kP2XRdjw+M+Hh4e3mFeO/ZtAe1y1D8GHh4e3gFe+4h2shnp5p4yPDw8vMO8JGLYl4ScVycryVEeDw8Pb81LGp6SjT5fgqSBYHMxVjwaDw8Pb8FrQ9tNQ0By7M4X8cWMeHh4eLfy8uAg/7z5Zl4M8PDw8D6Blx+v22h100bQhiMvmq7w8PDw1rxZM9Nmgnxbny1ccQGGh4eHN+J9laMtDPuYI5nxchY8PDy8A7x85NdXeZPWLCDeXJjh4eHh3cVLikF7ZZUjN1dr0XLj4eHhHeMlkyUTb15lX8EuCwMeHh7em3j5IbgtErOrrGQWPDw8vM/hzULVfRFqZ8fDw8M7x9uEEbP2gtnBuo2D8fDw8E7w2guwTaNAG2QkZeOxH3h4eHgp7w+Yfoi9eTE1lAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
